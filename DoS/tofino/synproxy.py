#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def acl_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_add_with___meta_init_miss_action_acl__(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_add_with_nop(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_add_with__drop(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_modify_with___meta_init_miss_action_acl__(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_modify_with_nop(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def acl_table_modify_with_nop_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_modify_with__drop(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def acl_table_modify_with__drop_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def acl_table_delete(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    pass

  def acl_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    pass

  def update_countt_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def time32_in_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def write_time_in_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def time32_eg_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def write_time_eg_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_check_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_check_reverse_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def read_seq_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def read_seq_reverse_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def write_seq_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_init_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_complete_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def relay_session_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def inbound_tran_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def outbound_tran_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def report_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def set_heavy_hitter_count_table_1_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def set_heavy_hitter_count_table_2_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def acl_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def init_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def update_countt_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def time32_in_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def write_time_in_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def time32_eg_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def write_time_eg_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def session_check_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def session_check_reverse_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def read_seq_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def read_seq_reverse_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def write_seq_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def session_init_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def session_complete_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def relay_session_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def inbound_tran_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def outbound_tran_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def report_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def set_heavy_hitter_count_table_1_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def set_heavy_hitter_count_table_2_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def acl_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def init_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def update_countt_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def update_countt_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def update_countt_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def time32_in_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def time32_in_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def time32_in_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def write_time_in_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def write_time_in_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def write_time_in_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def time32_eg_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def time32_eg_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def time32_eg_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def write_time_eg_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def write_time_eg_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def write_time_eg_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def session_check_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_check_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def session_check_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def session_check_reverse_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_check_reverse_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def session_check_reverse_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def read_seq_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def read_seq_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def read_seq_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def read_seq_reverse_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def read_seq_reverse_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def read_seq_reverse_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def write_seq_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def write_seq_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def write_seq_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def session_init_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_init_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def session_init_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def session_complete_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_complete_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def session_complete_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def relay_session_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def relay_session_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def relay_session_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def inbound_tran_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def inbound_tran_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def inbound_tran_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def outbound_tran_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def outbound_tran_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def outbound_tran_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def report_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def report_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def report_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def set_heavy_hitter_count_table_1_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def set_heavy_hitter_count_table_1_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def set_heavy_hitter_count_table_1_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def set_heavy_hitter_count_table_2_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def set_heavy_hitter_count_table_2_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def set_heavy_hitter_count_table_2_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def acl_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def acl_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def acl_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def init_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def init_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    pass

  def init_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    pass

  def update_countt_set_default_action_update_countt(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def time32_in_set_default_action_time32_in(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def time32_eg_set_default_action_time32_eg(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_check_set_default_action_lookup_session_map(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_check_reverse_set_default_action_lookup_session_map_reverse(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_init_table_set_default_action_sendback_sa(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def session_complete_table_set_default_action_sendh2syn(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def relay_session_table_set_default_action_sendh2ack(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def inbound_tran_table_set_default_action_inbound_transformation(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def outbound_tran_table_set_default_action_outbound_transformation(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def report_table_set_default_action_report(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def acl_set_default_action___meta_init_miss_action_acl__(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def acl_set_default_action_nop(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def acl_set_default_action__drop(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def init_set_default_action_init_action(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    pass

  def update_countt_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def time32_in_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def write_time_in_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def time32_eg_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def write_time_eg_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def session_check_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def session_check_reverse_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def read_seq_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def read_seq_reverse_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def write_seq_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def session_init_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def session_complete_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def relay_session_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def inbound_tran_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def outbound_tran_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def report_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def set_heavy_hitter_count_table_1_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def set_heavy_hitter_count_table_2_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def acl_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def init_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    pass

  def hash_fields_register(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def hash_fields_deregister(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    pass

  def hash_fields_get_digest(self, sess_hdl):
    """
    Parameters:
     - sess_hdl
    """
    pass

  def hash_fields_digest_notify_ack(self, sess_hdl, msg_ptr):
    """
    Parameters:
     - sess_hdl
     - msg_ptr
    """
    pass

  def set_learning_timeout(self, sess_hdl, dev_id, usecs):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - usecs
    """
    pass

  def tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
    """
    Parameters:
     - dev_tgt
     - tbl_name
     - type
    """
    pass

  def tbl_dbg_counter_get(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    pass

  def tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    pass

  def tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
    """
    Parameters:
     - dev_tgt
     - stage
     - type
    """
    pass

  def tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
    """
    Parameters:
     - dev_tgt
     - stage
    """
    pass

  def snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
    """
    Parameters:
     - dev_tgt
     - start_stage
     - end_stage
     - direction
    """
    pass

  def snapshot_delete(self, handle):
    """
    Parameters:
     - handle
    """
    pass

  def snapshot_state_set(self, handle, state, usecs):
    """
    Parameters:
     - handle
     - state
     - usecs
    """
    pass

  def snapshot_state_get(self, handle, pipe):
    """
    Parameters:
     - handle
     - pipe
    """
    pass

  def snapshot_timer_enable(self, handle, disable):
    """
    Parameters:
     - handle
     - disable
    """
    pass

  def snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
    """
    Parameters:
     - handle
     - trig_spec
     - trig_spec2
    """
    pass

  def snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
    """
    Parameters:
     - handle
     - pipe
     - stage_id
     - field_name
    """
    pass

  def snapshot_field_in_scope(self, dev_tgt, stage, direction, field_name):
    """
    Parameters:
     - dev_tgt
     - stage
     - direction
     - field_name
    """
    pass

  def register_read_h2_seq(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def register_write_h2_seq(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    pass

  def register_read_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def register_write_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    pass

  def register_read_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def register_write_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    pass

  def register_read_write_time_in(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def register_write_write_time_in(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    pass

  def register_read_write_time_eg(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def register_write_write_time_eg(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    pass

  def register_read_countt(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    pass

  def register_write_countt(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    pass

  def register_hw_sync_h2_seq(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_reset_all_h2_seq(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_range_reset_h2_seq(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    pass

  def register_write_all_h2_seq(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    pass

  def register_hw_sync_heavy_hitter_counter2(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_reset_all_heavy_hitter_counter2(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_range_reset_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    pass

  def register_write_all_heavy_hitter_counter2(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    pass

  def register_hw_sync_heavy_hitter_counter1(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_reset_all_heavy_hitter_counter1(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_range_reset_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    pass

  def register_write_all_heavy_hitter_counter1(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    pass

  def register_hw_sync_write_time_in(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_reset_all_write_time_in(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_range_reset_write_time_in(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    pass

  def register_write_all_write_time_in(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    pass

  def register_hw_sync_write_time_eg(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_reset_all_write_time_eg(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_range_reset_write_time_eg(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    pass

  def register_write_all_write_time_eg(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    pass

  def register_hw_sync_countt(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_reset_all_countt(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    pass

  def register_range_reset_countt(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    pass

  def register_write_all_countt(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def acl_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_match_spec_to_entry_hdl(sess_hdl, dev_tgt, match_spec, priority)
    return self.recv_acl_match_spec_to_entry_hdl()

  def send_acl_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_match_spec_to_entry_hdl', TMessageType.CALL, self._seqid)
    args = acl_match_spec_to_entry_hdl_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_match_spec_to_entry_hdl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_match_spec_to_entry_hdl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_match_spec_to_entry_hdl failed: unknown result");

  def acl_table_add_with___meta_init_miss_action_acl__(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_add_with___meta_init_miss_action_acl__(sess_hdl, dev_tgt, match_spec, priority)
    return self.recv_acl_table_add_with___meta_init_miss_action_acl__()

  def send_acl_table_add_with___meta_init_miss_action_acl__(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_add_with___meta_init_miss_action_acl__', TMessageType.CALL, self._seqid)
    args = acl_table_add_with___meta_init_miss_action_acl___args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_add_with___meta_init_miss_action_acl__(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_add_with___meta_init_miss_action_acl___result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_table_add_with___meta_init_miss_action_acl__ failed: unknown result");

  def acl_table_add_with_nop(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_add_with_nop(sess_hdl, dev_tgt, match_spec, priority)
    return self.recv_acl_table_add_with_nop()

  def send_acl_table_add_with_nop(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_add_with_nop', TMessageType.CALL, self._seqid)
    args = acl_table_add_with_nop_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_add_with_nop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_add_with_nop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_table_add_with_nop failed: unknown result");

  def acl_table_add_with__drop(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_add_with__drop(sess_hdl, dev_tgt, match_spec, priority)
    return self.recv_acl_table_add_with__drop()

  def send_acl_table_add_with__drop(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_add_with__drop', TMessageType.CALL, self._seqid)
    args = acl_table_add_with__drop_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_add_with__drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_add_with__drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_table_add_with__drop failed: unknown result");

  def acl_table_modify_with___meta_init_miss_action_acl__(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_acl_table_modify_with___meta_init_miss_action_acl__(sess_hdl, dev_id, entry)
    self.recv_acl_table_modify_with___meta_init_miss_action_acl__()

  def send_acl_table_modify_with___meta_init_miss_action_acl__(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('acl_table_modify_with___meta_init_miss_action_acl__', TMessageType.CALL, self._seqid)
    args = acl_table_modify_with___meta_init_miss_action_acl___args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_modify_with___meta_init_miss_action_acl__(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_modify_with___meta_init_miss_action_acl___result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(sess_hdl, dev_tgt, match_spec, priority)
    self.recv_acl_table_modify_with___meta_init_miss_action_acl___by_match_spec()

  def send_acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_modify_with___meta_init_miss_action_acl___by_match_spec', TMessageType.CALL, self._seqid)
    args = acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_modify_with_nop(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_acl_table_modify_with_nop(sess_hdl, dev_id, entry)
    self.recv_acl_table_modify_with_nop()

  def send_acl_table_modify_with_nop(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('acl_table_modify_with_nop', TMessageType.CALL, self._seqid)
    args = acl_table_modify_with_nop_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_modify_with_nop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_modify_with_nop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_modify_with_nop_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_modify_with_nop_by_match_spec(sess_hdl, dev_tgt, match_spec, priority)
    self.recv_acl_table_modify_with_nop_by_match_spec()

  def send_acl_table_modify_with_nop_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_modify_with_nop_by_match_spec', TMessageType.CALL, self._seqid)
    args = acl_table_modify_with_nop_by_match_spec_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_modify_with_nop_by_match_spec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_modify_with_nop_by_match_spec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_modify_with__drop(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_acl_table_modify_with__drop(sess_hdl, dev_id, entry)
    self.recv_acl_table_modify_with__drop()

  def send_acl_table_modify_with__drop(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('acl_table_modify_with__drop', TMessageType.CALL, self._seqid)
    args = acl_table_modify_with__drop_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_modify_with__drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_modify_with__drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_modify_with__drop_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_modify_with__drop_by_match_spec(sess_hdl, dev_tgt, match_spec, priority)
    self.recv_acl_table_modify_with__drop_by_match_spec()

  def send_acl_table_modify_with__drop_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_modify_with__drop_by_match_spec', TMessageType.CALL, self._seqid)
    args = acl_table_modify_with__drop_by_match_spec_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_modify_with__drop_by_match_spec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_modify_with__drop_by_match_spec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_delete(self, sess_hdl, dev_id, entry):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry
    """
    self.send_acl_table_delete(sess_hdl, dev_id, entry)
    self.recv_acl_table_delete()

  def send_acl_table_delete(self, sess_hdl, dev_id, entry):
    self._oprot.writeMessageBegin('acl_table_delete', TMessageType.CALL, self._seqid)
    args = acl_table_delete_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry = entry
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - match_spec
     - priority
    """
    self.send_acl_table_delete_by_match_spec(sess_hdl, dev_tgt, match_spec, priority)
    self.recv_acl_table_delete_by_match_spec()

  def send_acl_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec, priority):
    self._oprot.writeMessageBegin('acl_table_delete_by_match_spec', TMessageType.CALL, self._seqid)
    args = acl_table_delete_by_match_spec_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.match_spec = match_spec
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_delete_by_match_spec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_delete_by_match_spec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def update_countt_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_update_countt_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_update_countt_table_reset_default_entry()

  def send_update_countt_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('update_countt_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = update_countt_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def time32_in_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_time32_in_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_time32_in_table_reset_default_entry()

  def send_time32_in_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('time32_in_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = time32_in_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def write_time_in_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_write_time_in_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_write_time_in_table_reset_default_entry()

  def send_write_time_in_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('write_time_in_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = write_time_in_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_in_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_in_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def time32_eg_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_time32_eg_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_time32_eg_table_reset_default_entry()

  def send_time32_eg_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('time32_eg_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = time32_eg_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def write_time_eg_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_write_time_eg_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_write_time_eg_table_reset_default_entry()

  def send_write_time_eg_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('write_time_eg_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = write_time_eg_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_eg_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_eg_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_check_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_check_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_session_check_table_reset_default_entry()

  def send_session_check_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_check_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = session_check_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_check_reverse_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_check_reverse_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_session_check_reverse_table_reset_default_entry()

  def send_session_check_reverse_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_check_reverse_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = session_check_reverse_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def read_seq_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_read_seq_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_read_seq_table_reset_default_entry()

  def send_read_seq_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('read_seq_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = read_seq_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def read_seq_reverse_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_read_seq_reverse_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_read_seq_reverse_table_reset_default_entry()

  def send_read_seq_reverse_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('read_seq_reverse_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = read_seq_reverse_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_reverse_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_reverse_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def write_seq_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_write_seq_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_write_seq_table_reset_default_entry()

  def send_write_seq_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('write_seq_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = write_seq_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_seq_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_seq_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_init_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_init_table_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_session_init_table_table_reset_default_entry()

  def send_session_init_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_init_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = session_init_table_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_complete_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_complete_table_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_session_complete_table_table_reset_default_entry()

  def send_session_complete_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_complete_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = session_complete_table_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def relay_session_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_relay_session_table_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_relay_session_table_table_reset_default_entry()

  def send_relay_session_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('relay_session_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = relay_session_table_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def inbound_tran_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_inbound_tran_table_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_inbound_tran_table_table_reset_default_entry()

  def send_inbound_tran_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('inbound_tran_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def outbound_tran_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_outbound_tran_table_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_outbound_tran_table_table_reset_default_entry()

  def send_outbound_tran_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('outbound_tran_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def report_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_report_table_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_report_table_table_reset_default_entry()

  def send_report_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('report_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = report_table_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def set_heavy_hitter_count_table_1_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_set_heavy_hitter_count_table_1_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_set_heavy_hitter_count_table_1_table_reset_default_entry()

  def send_set_heavy_hitter_count_table_1_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def set_heavy_hitter_count_table_2_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_set_heavy_hitter_count_table_2_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_set_heavy_hitter_count_table_2_table_reset_default_entry()

  def send_set_heavy_hitter_count_table_2_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_acl_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_acl_table_reset_default_entry()

  def send_acl_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('acl_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = acl_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def init_table_reset_default_entry(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_init_table_reset_default_entry(sess_hdl, dev_tgt)
    self.recv_init_table_reset_default_entry()

  def send_init_table_reset_default_entry(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('init_table_reset_default_entry', TMessageType.CALL, self._seqid)
    args = init_table_reset_default_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_table_reset_default_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_table_reset_default_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def update_countt_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_update_countt_get_entry_count(sess_hdl, dev_id)
    return self.recv_update_countt_get_entry_count()

  def send_update_countt_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('update_countt_get_entry_count', TMessageType.CALL, self._seqid)
    args = update_countt_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_countt_get_entry_count failed: unknown result");

  def time32_in_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_time32_in_get_entry_count(sess_hdl, dev_id)
    return self.recv_time32_in_get_entry_count()

  def send_time32_in_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('time32_in_get_entry_count', TMessageType.CALL, self._seqid)
    args = time32_in_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_in_get_entry_count failed: unknown result");

  def write_time_in_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_write_time_in_get_entry_count(sess_hdl, dev_id)
    return self.recv_write_time_in_get_entry_count()

  def send_write_time_in_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('write_time_in_get_entry_count', TMessageType.CALL, self._seqid)
    args = write_time_in_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_in_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_in_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_in_get_entry_count failed: unknown result");

  def time32_eg_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_time32_eg_get_entry_count(sess_hdl, dev_id)
    return self.recv_time32_eg_get_entry_count()

  def send_time32_eg_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('time32_eg_get_entry_count', TMessageType.CALL, self._seqid)
    args = time32_eg_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_eg_get_entry_count failed: unknown result");

  def write_time_eg_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_write_time_eg_get_entry_count(sess_hdl, dev_id)
    return self.recv_write_time_eg_get_entry_count()

  def send_write_time_eg_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('write_time_eg_get_entry_count', TMessageType.CALL, self._seqid)
    args = write_time_eg_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_eg_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_eg_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_eg_get_entry_count failed: unknown result");

  def session_check_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_session_check_get_entry_count(sess_hdl, dev_id)
    return self.recv_session_check_get_entry_count()

  def send_session_check_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('session_check_get_entry_count', TMessageType.CALL, self._seqid)
    args = session_check_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_get_entry_count failed: unknown result");

  def session_check_reverse_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_session_check_reverse_get_entry_count(sess_hdl, dev_id)
    return self.recv_session_check_reverse_get_entry_count()

  def send_session_check_reverse_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('session_check_reverse_get_entry_count', TMessageType.CALL, self._seqid)
    args = session_check_reverse_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_reverse_get_entry_count failed: unknown result");

  def read_seq_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_read_seq_get_entry_count(sess_hdl, dev_id)
    return self.recv_read_seq_get_entry_count()

  def send_read_seq_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('read_seq_get_entry_count', TMessageType.CALL, self._seqid)
    args = read_seq_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_get_entry_count failed: unknown result");

  def read_seq_reverse_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_read_seq_reverse_get_entry_count(sess_hdl, dev_id)
    return self.recv_read_seq_reverse_get_entry_count()

  def send_read_seq_reverse_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('read_seq_reverse_get_entry_count', TMessageType.CALL, self._seqid)
    args = read_seq_reverse_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_reverse_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_reverse_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_reverse_get_entry_count failed: unknown result");

  def write_seq_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_write_seq_get_entry_count(sess_hdl, dev_id)
    return self.recv_write_seq_get_entry_count()

  def send_write_seq_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('write_seq_get_entry_count', TMessageType.CALL, self._seqid)
    args = write_seq_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_seq_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_seq_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_seq_get_entry_count failed: unknown result");

  def session_init_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_session_init_table_get_entry_count(sess_hdl, dev_id)
    return self.recv_session_init_table_get_entry_count()

  def send_session_init_table_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('session_init_table_get_entry_count', TMessageType.CALL, self._seqid)
    args = session_init_table_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_init_table_get_entry_count failed: unknown result");

  def session_complete_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_session_complete_table_get_entry_count(sess_hdl, dev_id)
    return self.recv_session_complete_table_get_entry_count()

  def send_session_complete_table_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('session_complete_table_get_entry_count', TMessageType.CALL, self._seqid)
    args = session_complete_table_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_complete_table_get_entry_count failed: unknown result");

  def relay_session_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_relay_session_table_get_entry_count(sess_hdl, dev_id)
    return self.recv_relay_session_table_get_entry_count()

  def send_relay_session_table_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('relay_session_table_get_entry_count', TMessageType.CALL, self._seqid)
    args = relay_session_table_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "relay_session_table_get_entry_count failed: unknown result");

  def inbound_tran_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_inbound_tran_table_get_entry_count(sess_hdl, dev_id)
    return self.recv_inbound_tran_table_get_entry_count()

  def send_inbound_tran_table_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('inbound_tran_table_get_entry_count', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inbound_tran_table_get_entry_count failed: unknown result");

  def outbound_tran_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_outbound_tran_table_get_entry_count(sess_hdl, dev_id)
    return self.recv_outbound_tran_table_get_entry_count()

  def send_outbound_tran_table_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('outbound_tran_table_get_entry_count', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "outbound_tran_table_get_entry_count failed: unknown result");

  def report_table_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_report_table_get_entry_count(sess_hdl, dev_id)
    return self.recv_report_table_get_entry_count()

  def send_report_table_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('report_table_get_entry_count', TMessageType.CALL, self._seqid)
    args = report_table_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "report_table_get_entry_count failed: unknown result");

  def set_heavy_hitter_count_table_1_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_set_heavy_hitter_count_table_1_get_entry_count(sess_hdl, dev_id)
    return self.recv_set_heavy_hitter_count_table_1_get_entry_count()

  def send_set_heavy_hitter_count_table_1_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_get_entry_count', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_1_get_entry_count failed: unknown result");

  def set_heavy_hitter_count_table_2_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_set_heavy_hitter_count_table_2_get_entry_count(sess_hdl, dev_id)
    return self.recv_set_heavy_hitter_count_table_2_get_entry_count()

  def send_set_heavy_hitter_count_table_2_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_get_entry_count', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_2_get_entry_count failed: unknown result");

  def acl_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_acl_get_entry_count(sess_hdl, dev_id)
    return self.recv_acl_get_entry_count()

  def send_acl_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('acl_get_entry_count', TMessageType.CALL, self._seqid)
    args = acl_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_get_entry_count failed: unknown result");

  def init_get_entry_count(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_init_get_entry_count(sess_hdl, dev_id)
    return self.recv_init_get_entry_count()

  def send_init_get_entry_count(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('init_get_entry_count', TMessageType.CALL, self._seqid)
    args = init_get_entry_count_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_get_entry_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_get_entry_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init_get_entry_count failed: unknown result");

  def update_countt_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_update_countt_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_update_countt_get_first_entry_handle()

  def send_update_countt_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('update_countt_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = update_countt_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_countt_get_first_entry_handle failed: unknown result");

  def update_countt_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_update_countt_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_update_countt_get_next_entry_handles()

  def send_update_countt_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('update_countt_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = update_countt_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_countt_get_next_entry_handles failed: unknown result");

  def update_countt_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_update_countt_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_update_countt_get_entry()

  def send_update_countt_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('update_countt_get_entry', TMessageType.CALL, self._seqid)
    args = update_countt_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_countt_get_entry failed: unknown result");

  def time32_in_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_time32_in_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_time32_in_get_first_entry_handle()

  def send_time32_in_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('time32_in_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = time32_in_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_in_get_first_entry_handle failed: unknown result");

  def time32_in_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_time32_in_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_time32_in_get_next_entry_handles()

  def send_time32_in_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('time32_in_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = time32_in_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_in_get_next_entry_handles failed: unknown result");

  def time32_in_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_time32_in_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_time32_in_get_entry()

  def send_time32_in_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('time32_in_get_entry', TMessageType.CALL, self._seqid)
    args = time32_in_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_in_get_entry failed: unknown result");

  def write_time_in_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_write_time_in_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_write_time_in_get_first_entry_handle()

  def send_write_time_in_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('write_time_in_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = write_time_in_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_in_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_in_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_in_get_first_entry_handle failed: unknown result");

  def write_time_in_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_write_time_in_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_write_time_in_get_next_entry_handles()

  def send_write_time_in_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('write_time_in_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = write_time_in_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_in_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_in_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_in_get_next_entry_handles failed: unknown result");

  def write_time_in_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_write_time_in_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_write_time_in_get_entry()

  def send_write_time_in_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('write_time_in_get_entry', TMessageType.CALL, self._seqid)
    args = write_time_in_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_in_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_in_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_in_get_entry failed: unknown result");

  def time32_eg_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_time32_eg_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_time32_eg_get_first_entry_handle()

  def send_time32_eg_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('time32_eg_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = time32_eg_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_eg_get_first_entry_handle failed: unknown result");

  def time32_eg_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_time32_eg_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_time32_eg_get_next_entry_handles()

  def send_time32_eg_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('time32_eg_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = time32_eg_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_eg_get_next_entry_handles failed: unknown result");

  def time32_eg_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_time32_eg_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_time32_eg_get_entry()

  def send_time32_eg_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('time32_eg_get_entry', TMessageType.CALL, self._seqid)
    args = time32_eg_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_eg_get_entry failed: unknown result");

  def write_time_eg_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_write_time_eg_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_write_time_eg_get_first_entry_handle()

  def send_write_time_eg_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('write_time_eg_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = write_time_eg_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_eg_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_eg_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_eg_get_first_entry_handle failed: unknown result");

  def write_time_eg_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_write_time_eg_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_write_time_eg_get_next_entry_handles()

  def send_write_time_eg_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('write_time_eg_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = write_time_eg_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_eg_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_eg_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_eg_get_next_entry_handles failed: unknown result");

  def write_time_eg_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_write_time_eg_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_write_time_eg_get_entry()

  def send_write_time_eg_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('write_time_eg_get_entry', TMessageType.CALL, self._seqid)
    args = write_time_eg_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_eg_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_eg_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_time_eg_get_entry failed: unknown result");

  def session_check_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_check_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_session_check_get_first_entry_handle()

  def send_session_check_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_check_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = session_check_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_get_first_entry_handle failed: unknown result");

  def session_check_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_session_check_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_session_check_get_next_entry_handles()

  def send_session_check_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('session_check_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = session_check_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_get_next_entry_handles failed: unknown result");

  def session_check_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_session_check_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_session_check_get_entry()

  def send_session_check_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('session_check_get_entry', TMessageType.CALL, self._seqid)
    args = session_check_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_get_entry failed: unknown result");

  def session_check_reverse_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_check_reverse_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_session_check_reverse_get_first_entry_handle()

  def send_session_check_reverse_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_check_reverse_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = session_check_reverse_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_reverse_get_first_entry_handle failed: unknown result");

  def session_check_reverse_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_session_check_reverse_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_session_check_reverse_get_next_entry_handles()

  def send_session_check_reverse_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('session_check_reverse_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = session_check_reverse_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_reverse_get_next_entry_handles failed: unknown result");

  def session_check_reverse_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_session_check_reverse_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_session_check_reverse_get_entry()

  def send_session_check_reverse_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('session_check_reverse_get_entry', TMessageType.CALL, self._seqid)
    args = session_check_reverse_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_reverse_get_entry failed: unknown result");

  def read_seq_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_read_seq_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_read_seq_get_first_entry_handle()

  def send_read_seq_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('read_seq_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = read_seq_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_get_first_entry_handle failed: unknown result");

  def read_seq_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_read_seq_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_read_seq_get_next_entry_handles()

  def send_read_seq_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('read_seq_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = read_seq_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_get_next_entry_handles failed: unknown result");

  def read_seq_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_read_seq_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_read_seq_get_entry()

  def send_read_seq_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('read_seq_get_entry', TMessageType.CALL, self._seqid)
    args = read_seq_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_get_entry failed: unknown result");

  def read_seq_reverse_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_read_seq_reverse_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_read_seq_reverse_get_first_entry_handle()

  def send_read_seq_reverse_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('read_seq_reverse_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = read_seq_reverse_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_reverse_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_reverse_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_reverse_get_first_entry_handle failed: unknown result");

  def read_seq_reverse_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_read_seq_reverse_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_read_seq_reverse_get_next_entry_handles()

  def send_read_seq_reverse_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('read_seq_reverse_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = read_seq_reverse_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_reverse_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_reverse_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_reverse_get_next_entry_handles failed: unknown result");

  def read_seq_reverse_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_read_seq_reverse_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_read_seq_reverse_get_entry()

  def send_read_seq_reverse_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('read_seq_reverse_get_entry', TMessageType.CALL, self._seqid)
    args = read_seq_reverse_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_reverse_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_reverse_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read_seq_reverse_get_entry failed: unknown result");

  def write_seq_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_write_seq_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_write_seq_get_first_entry_handle()

  def send_write_seq_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('write_seq_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = write_seq_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_seq_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_seq_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_seq_get_first_entry_handle failed: unknown result");

  def write_seq_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_write_seq_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_write_seq_get_next_entry_handles()

  def send_write_seq_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('write_seq_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = write_seq_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_seq_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_seq_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_seq_get_next_entry_handles failed: unknown result");

  def write_seq_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_write_seq_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_write_seq_get_entry()

  def send_write_seq_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('write_seq_get_entry', TMessageType.CALL, self._seqid)
    args = write_seq_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_seq_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_seq_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write_seq_get_entry failed: unknown result");

  def session_init_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_init_table_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_session_init_table_get_first_entry_handle()

  def send_session_init_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_init_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = session_init_table_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_init_table_get_first_entry_handle failed: unknown result");

  def session_init_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_session_init_table_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_session_init_table_get_next_entry_handles()

  def send_session_init_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('session_init_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = session_init_table_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_init_table_get_next_entry_handles failed: unknown result");

  def session_init_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_session_init_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_session_init_table_get_entry()

  def send_session_init_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('session_init_table_get_entry', TMessageType.CALL, self._seqid)
    args = session_init_table_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_init_table_get_entry failed: unknown result");

  def session_complete_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_complete_table_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_session_complete_table_get_first_entry_handle()

  def send_session_complete_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_complete_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = session_complete_table_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_complete_table_get_first_entry_handle failed: unknown result");

  def session_complete_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_session_complete_table_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_session_complete_table_get_next_entry_handles()

  def send_session_complete_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('session_complete_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = session_complete_table_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_complete_table_get_next_entry_handles failed: unknown result");

  def session_complete_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_session_complete_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_session_complete_table_get_entry()

  def send_session_complete_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('session_complete_table_get_entry', TMessageType.CALL, self._seqid)
    args = session_complete_table_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_complete_table_get_entry failed: unknown result");

  def relay_session_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_relay_session_table_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_relay_session_table_get_first_entry_handle()

  def send_relay_session_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('relay_session_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = relay_session_table_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "relay_session_table_get_first_entry_handle failed: unknown result");

  def relay_session_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_relay_session_table_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_relay_session_table_get_next_entry_handles()

  def send_relay_session_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('relay_session_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = relay_session_table_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "relay_session_table_get_next_entry_handles failed: unknown result");

  def relay_session_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_relay_session_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_relay_session_table_get_entry()

  def send_relay_session_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('relay_session_table_get_entry', TMessageType.CALL, self._seqid)
    args = relay_session_table_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "relay_session_table_get_entry failed: unknown result");

  def inbound_tran_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_inbound_tran_table_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_inbound_tran_table_get_first_entry_handle()

  def send_inbound_tran_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('inbound_tran_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inbound_tran_table_get_first_entry_handle failed: unknown result");

  def inbound_tran_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_inbound_tran_table_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_inbound_tran_table_get_next_entry_handles()

  def send_inbound_tran_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('inbound_tran_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inbound_tran_table_get_next_entry_handles failed: unknown result");

  def inbound_tran_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_inbound_tran_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_inbound_tran_table_get_entry()

  def send_inbound_tran_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('inbound_tran_table_get_entry', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inbound_tran_table_get_entry failed: unknown result");

  def outbound_tran_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_outbound_tran_table_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_outbound_tran_table_get_first_entry_handle()

  def send_outbound_tran_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('outbound_tran_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "outbound_tran_table_get_first_entry_handle failed: unknown result");

  def outbound_tran_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_outbound_tran_table_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_outbound_tran_table_get_next_entry_handles()

  def send_outbound_tran_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('outbound_tran_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "outbound_tran_table_get_next_entry_handles failed: unknown result");

  def outbound_tran_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_outbound_tran_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_outbound_tran_table_get_entry()

  def send_outbound_tran_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('outbound_tran_table_get_entry', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "outbound_tran_table_get_entry failed: unknown result");

  def report_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_report_table_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_report_table_get_first_entry_handle()

  def send_report_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('report_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = report_table_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "report_table_get_first_entry_handle failed: unknown result");

  def report_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_report_table_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_report_table_get_next_entry_handles()

  def send_report_table_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('report_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = report_table_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "report_table_get_next_entry_handles failed: unknown result");

  def report_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_report_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_report_table_get_entry()

  def send_report_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('report_table_get_entry', TMessageType.CALL, self._seqid)
    args = report_table_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "report_table_get_entry failed: unknown result");

  def set_heavy_hitter_count_table_1_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_set_heavy_hitter_count_table_1_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_set_heavy_hitter_count_table_1_get_first_entry_handle()

  def send_set_heavy_hitter_count_table_1_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_1_get_first_entry_handle failed: unknown result");

  def set_heavy_hitter_count_table_1_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_set_heavy_hitter_count_table_1_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_set_heavy_hitter_count_table_1_get_next_entry_handles()

  def send_set_heavy_hitter_count_table_1_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_1_get_next_entry_handles failed: unknown result");

  def set_heavy_hitter_count_table_1_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_set_heavy_hitter_count_table_1_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_set_heavy_hitter_count_table_1_get_entry()

  def send_set_heavy_hitter_count_table_1_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_get_entry', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_1_get_entry failed: unknown result");

  def set_heavy_hitter_count_table_2_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_set_heavy_hitter_count_table_2_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_set_heavy_hitter_count_table_2_get_first_entry_handle()

  def send_set_heavy_hitter_count_table_2_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_2_get_first_entry_handle failed: unknown result");

  def set_heavy_hitter_count_table_2_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_set_heavy_hitter_count_table_2_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_set_heavy_hitter_count_table_2_get_next_entry_handles()

  def send_set_heavy_hitter_count_table_2_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_2_get_next_entry_handles failed: unknown result");

  def set_heavy_hitter_count_table_2_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_set_heavy_hitter_count_table_2_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_set_heavy_hitter_count_table_2_get_entry()

  def send_set_heavy_hitter_count_table_2_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_get_entry', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_2_get_entry failed: unknown result");

  def acl_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_acl_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_acl_get_first_entry_handle()

  def send_acl_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('acl_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = acl_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_get_first_entry_handle failed: unknown result");

  def acl_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_acl_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_acl_get_next_entry_handles()

  def send_acl_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('acl_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = acl_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_get_next_entry_handles failed: unknown result");

  def acl_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_acl_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_acl_get_entry()

  def send_acl_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('acl_get_entry', TMessageType.CALL, self._seqid)
    args = acl_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_get_entry failed: unknown result");

  def init_get_first_entry_handle(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_init_get_first_entry_handle(sess_hdl, dev_tgt)
    return self.recv_init_get_first_entry_handle()

  def send_init_get_first_entry_handle(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('init_get_first_entry_handle', TMessageType.CALL, self._seqid)
    args = init_get_first_entry_handle_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_get_first_entry_handle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_get_first_entry_handle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init_get_first_entry_handle failed: unknown result");

  def init_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - n
    """
    self.send_init_get_next_entry_handles(sess_hdl, dev_id, entry_hdl, n)
    return self.recv_init_get_next_entry_handles()

  def send_init_get_next_entry_handles(self, sess_hdl, dev_id, entry_hdl, n):
    self._oprot.writeMessageBegin('init_get_next_entry_handles', TMessageType.CALL, self._seqid)
    args = init_get_next_entry_handles_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_get_next_entry_handles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_get_next_entry_handles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init_get_next_entry_handles failed: unknown result");

  def init_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw
    """
    self.send_init_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
    return self.recv_init_get_entry()

  def send_init_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
    self._oprot.writeMessageBegin('init_get_entry', TMessageType.CALL, self._seqid)
    args = init_get_entry_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.entry_hdl = entry_hdl
    args.read_from_hw = read_from_hw
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_get_entry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_get_entry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init_get_entry failed: unknown result");

  def update_countt_set_default_action_update_countt(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_update_countt_set_default_action_update_countt(sess_hdl, dev_tgt)
    return self.recv_update_countt_set_default_action_update_countt()

  def send_update_countt_set_default_action_update_countt(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('update_countt_set_default_action_update_countt', TMessageType.CALL, self._seqid)
    args = update_countt_set_default_action_update_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_set_default_action_update_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_set_default_action_update_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_countt_set_default_action_update_countt failed: unknown result");

  def time32_in_set_default_action_time32_in(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_time32_in_set_default_action_time32_in(sess_hdl, dev_tgt)
    return self.recv_time32_in_set_default_action_time32_in()

  def send_time32_in_set_default_action_time32_in(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('time32_in_set_default_action_time32_in', TMessageType.CALL, self._seqid)
    args = time32_in_set_default_action_time32_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_set_default_action_time32_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_set_default_action_time32_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_in_set_default_action_time32_in failed: unknown result");

  def time32_eg_set_default_action_time32_eg(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_time32_eg_set_default_action_time32_eg(sess_hdl, dev_tgt)
    return self.recv_time32_eg_set_default_action_time32_eg()

  def send_time32_eg_set_default_action_time32_eg(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('time32_eg_set_default_action_time32_eg', TMessageType.CALL, self._seqid)
    args = time32_eg_set_default_action_time32_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_set_default_action_time32_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_set_default_action_time32_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time32_eg_set_default_action_time32_eg failed: unknown result");

  def session_check_set_default_action_lookup_session_map(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_check_set_default_action_lookup_session_map(sess_hdl, dev_tgt)
    return self.recv_session_check_set_default_action_lookup_session_map()

  def send_session_check_set_default_action_lookup_session_map(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_check_set_default_action_lookup_session_map', TMessageType.CALL, self._seqid)
    args = session_check_set_default_action_lookup_session_map_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_set_default_action_lookup_session_map(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_set_default_action_lookup_session_map_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_set_default_action_lookup_session_map failed: unknown result");

  def session_check_reverse_set_default_action_lookup_session_map_reverse(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_check_reverse_set_default_action_lookup_session_map_reverse(sess_hdl, dev_tgt)
    return self.recv_session_check_reverse_set_default_action_lookup_session_map_reverse()

  def send_session_check_reverse_set_default_action_lookup_session_map_reverse(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_check_reverse_set_default_action_lookup_session_map_reverse', TMessageType.CALL, self._seqid)
    args = session_check_reverse_set_default_action_lookup_session_map_reverse_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_set_default_action_lookup_session_map_reverse(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_set_default_action_lookup_session_map_reverse_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_check_reverse_set_default_action_lookup_session_map_reverse failed: unknown result");

  def session_init_table_set_default_action_sendback_sa(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_init_table_set_default_action_sendback_sa(sess_hdl, dev_tgt)
    return self.recv_session_init_table_set_default_action_sendback_sa()

  def send_session_init_table_set_default_action_sendback_sa(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_init_table_set_default_action_sendback_sa', TMessageType.CALL, self._seqid)
    args = session_init_table_set_default_action_sendback_sa_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_set_default_action_sendback_sa(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_set_default_action_sendback_sa_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_init_table_set_default_action_sendback_sa failed: unknown result");

  def session_complete_table_set_default_action_sendh2syn(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_session_complete_table_set_default_action_sendh2syn(sess_hdl, dev_tgt)
    return self.recv_session_complete_table_set_default_action_sendh2syn()

  def send_session_complete_table_set_default_action_sendh2syn(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('session_complete_table_set_default_action_sendh2syn', TMessageType.CALL, self._seqid)
    args = session_complete_table_set_default_action_sendh2syn_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_set_default_action_sendh2syn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_set_default_action_sendh2syn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "session_complete_table_set_default_action_sendh2syn failed: unknown result");

  def relay_session_table_set_default_action_sendh2ack(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_relay_session_table_set_default_action_sendh2ack(sess_hdl, dev_tgt)
    return self.recv_relay_session_table_set_default_action_sendh2ack()

  def send_relay_session_table_set_default_action_sendh2ack(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('relay_session_table_set_default_action_sendh2ack', TMessageType.CALL, self._seqid)
    args = relay_session_table_set_default_action_sendh2ack_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_set_default_action_sendh2ack(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_set_default_action_sendh2ack_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "relay_session_table_set_default_action_sendh2ack failed: unknown result");

  def inbound_tran_table_set_default_action_inbound_transformation(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_inbound_tran_table_set_default_action_inbound_transformation(sess_hdl, dev_tgt)
    return self.recv_inbound_tran_table_set_default_action_inbound_transformation()

  def send_inbound_tran_table_set_default_action_inbound_transformation(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('inbound_tran_table_set_default_action_inbound_transformation', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_set_default_action_inbound_transformation_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_set_default_action_inbound_transformation(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_set_default_action_inbound_transformation_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inbound_tran_table_set_default_action_inbound_transformation failed: unknown result");

  def outbound_tran_table_set_default_action_outbound_transformation(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_outbound_tran_table_set_default_action_outbound_transformation(sess_hdl, dev_tgt)
    return self.recv_outbound_tran_table_set_default_action_outbound_transformation()

  def send_outbound_tran_table_set_default_action_outbound_transformation(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('outbound_tran_table_set_default_action_outbound_transformation', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_set_default_action_outbound_transformation_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_set_default_action_outbound_transformation(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_set_default_action_outbound_transformation_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "outbound_tran_table_set_default_action_outbound_transformation failed: unknown result");

  def report_table_set_default_action_report(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_report_table_set_default_action_report(sess_hdl, dev_tgt)
    return self.recv_report_table_set_default_action_report()

  def send_report_table_set_default_action_report(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('report_table_set_default_action_report', TMessageType.CALL, self._seqid)
    args = report_table_set_default_action_report_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_set_default_action_report(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_set_default_action_report_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "report_table_set_default_action_report failed: unknown result");

  def set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(sess_hdl, dev_tgt)
    return self.recv_set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1()

  def send_set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1 failed: unknown result");

  def set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(sess_hdl, dev_tgt)
    return self.recv_set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2()

  def send_set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2 failed: unknown result");

  def acl_set_default_action___meta_init_miss_action_acl__(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_acl_set_default_action___meta_init_miss_action_acl__(sess_hdl, dev_tgt)
    return self.recv_acl_set_default_action___meta_init_miss_action_acl__()

  def send_acl_set_default_action___meta_init_miss_action_acl__(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('acl_set_default_action___meta_init_miss_action_acl__', TMessageType.CALL, self._seqid)
    args = acl_set_default_action___meta_init_miss_action_acl___args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_set_default_action___meta_init_miss_action_acl__(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_set_default_action___meta_init_miss_action_acl___result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_set_default_action___meta_init_miss_action_acl__ failed: unknown result");

  def acl_set_default_action_nop(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_acl_set_default_action_nop(sess_hdl, dev_tgt)
    return self.recv_acl_set_default_action_nop()

  def send_acl_set_default_action_nop(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('acl_set_default_action_nop', TMessageType.CALL, self._seqid)
    args = acl_set_default_action_nop_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_set_default_action_nop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_set_default_action_nop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_set_default_action_nop failed: unknown result");

  def acl_set_default_action__drop(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_acl_set_default_action__drop(sess_hdl, dev_tgt)
    return self.recv_acl_set_default_action__drop()

  def send_acl_set_default_action__drop(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('acl_set_default_action__drop', TMessageType.CALL, self._seqid)
    args = acl_set_default_action__drop_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_set_default_action__drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_set_default_action__drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acl_set_default_action__drop failed: unknown result");

  def init_set_default_action_init_action(self, sess_hdl, dev_tgt, action_spec):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - action_spec
    """
    self.send_init_set_default_action_init_action(sess_hdl, dev_tgt, action_spec)
    return self.recv_init_set_default_action_init_action()

  def send_init_set_default_action_init_action(self, sess_hdl, dev_tgt, action_spec):
    self._oprot.writeMessageBegin('init_set_default_action_init_action', TMessageType.CALL, self._seqid)
    args = init_set_default_action_init_action_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.action_spec = action_spec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_set_default_action_init_action(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_set_default_action_init_action_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init_set_default_action_init_action failed: unknown result");

  def update_countt_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_update_countt_set_property(sess_hdl, dev_id, property, value)
    self.recv_update_countt_set_property()

  def send_update_countt_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('update_countt_set_property', TMessageType.CALL, self._seqid)
    args = update_countt_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_countt_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_countt_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def time32_in_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_time32_in_set_property(sess_hdl, dev_id, property, value)
    self.recv_time32_in_set_property()

  def send_time32_in_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('time32_in_set_property', TMessageType.CALL, self._seqid)
    args = time32_in_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_in_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_in_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def write_time_in_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_write_time_in_set_property(sess_hdl, dev_id, property, value)
    self.recv_write_time_in_set_property()

  def send_write_time_in_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('write_time_in_set_property', TMessageType.CALL, self._seqid)
    args = write_time_in_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_in_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_in_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def time32_eg_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_time32_eg_set_property(sess_hdl, dev_id, property, value)
    self.recv_time32_eg_set_property()

  def send_time32_eg_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('time32_eg_set_property', TMessageType.CALL, self._seqid)
    args = time32_eg_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time32_eg_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time32_eg_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def write_time_eg_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_write_time_eg_set_property(sess_hdl, dev_id, property, value)
    self.recv_write_time_eg_set_property()

  def send_write_time_eg_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('write_time_eg_set_property', TMessageType.CALL, self._seqid)
    args = write_time_eg_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_time_eg_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_time_eg_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_check_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_session_check_set_property(sess_hdl, dev_id, property, value)
    self.recv_session_check_set_property()

  def send_session_check_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('session_check_set_property', TMessageType.CALL, self._seqid)
    args = session_check_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_check_reverse_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_session_check_reverse_set_property(sess_hdl, dev_id, property, value)
    self.recv_session_check_reverse_set_property()

  def send_session_check_reverse_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('session_check_reverse_set_property', TMessageType.CALL, self._seqid)
    args = session_check_reverse_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_check_reverse_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_check_reverse_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def read_seq_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_read_seq_set_property(sess_hdl, dev_id, property, value)
    self.recv_read_seq_set_property()

  def send_read_seq_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('read_seq_set_property', TMessageType.CALL, self._seqid)
    args = read_seq_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def read_seq_reverse_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_read_seq_reverse_set_property(sess_hdl, dev_id, property, value)
    self.recv_read_seq_reverse_set_property()

  def send_read_seq_reverse_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('read_seq_reverse_set_property', TMessageType.CALL, self._seqid)
    args = read_seq_reverse_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read_seq_reverse_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = read_seq_reverse_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def write_seq_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_write_seq_set_property(sess_hdl, dev_id, property, value)
    self.recv_write_seq_set_property()

  def send_write_seq_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('write_seq_set_property', TMessageType.CALL, self._seqid)
    args = write_seq_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write_seq_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = write_seq_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_init_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_session_init_table_set_property(sess_hdl, dev_id, property, value)
    self.recv_session_init_table_set_property()

  def send_session_init_table_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('session_init_table_set_property', TMessageType.CALL, self._seqid)
    args = session_init_table_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_init_table_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_init_table_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def session_complete_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_session_complete_table_set_property(sess_hdl, dev_id, property, value)
    self.recv_session_complete_table_set_property()

  def send_session_complete_table_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('session_complete_table_set_property', TMessageType.CALL, self._seqid)
    args = session_complete_table_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_session_complete_table_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = session_complete_table_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def relay_session_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_relay_session_table_set_property(sess_hdl, dev_id, property, value)
    self.recv_relay_session_table_set_property()

  def send_relay_session_table_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('relay_session_table_set_property', TMessageType.CALL, self._seqid)
    args = relay_session_table_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_relay_session_table_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = relay_session_table_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def inbound_tran_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_inbound_tran_table_set_property(sess_hdl, dev_id, property, value)
    self.recv_inbound_tran_table_set_property()

  def send_inbound_tran_table_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('inbound_tran_table_set_property', TMessageType.CALL, self._seqid)
    args = inbound_tran_table_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inbound_tran_table_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inbound_tran_table_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def outbound_tran_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_outbound_tran_table_set_property(sess_hdl, dev_id, property, value)
    self.recv_outbound_tran_table_set_property()

  def send_outbound_tran_table_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('outbound_tran_table_set_property', TMessageType.CALL, self._seqid)
    args = outbound_tran_table_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_outbound_tran_table_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = outbound_tran_table_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def report_table_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_report_table_set_property(sess_hdl, dev_id, property, value)
    self.recv_report_table_set_property()

  def send_report_table_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('report_table_set_property', TMessageType.CALL, self._seqid)
    args = report_table_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_report_table_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = report_table_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def set_heavy_hitter_count_table_1_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_set_heavy_hitter_count_table_1_set_property(sess_hdl, dev_id, property, value)
    self.recv_set_heavy_hitter_count_table_1_set_property()

  def send_set_heavy_hitter_count_table_1_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_1_set_property', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_1_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_1_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_1_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def set_heavy_hitter_count_table_2_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_set_heavy_hitter_count_table_2_set_property(sess_hdl, dev_id, property, value)
    self.recv_set_heavy_hitter_count_table_2_set_property()

  def send_set_heavy_hitter_count_table_2_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('set_heavy_hitter_count_table_2_set_property', TMessageType.CALL, self._seqid)
    args = set_heavy_hitter_count_table_2_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_heavy_hitter_count_table_2_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_heavy_hitter_count_table_2_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def acl_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_acl_set_property(sess_hdl, dev_id, property, value)
    self.recv_acl_set_property()

  def send_acl_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('acl_set_property', TMessageType.CALL, self._seqid)
    args = acl_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acl_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acl_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def init_set_property(self, sess_hdl, dev_id, property, value):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - property
     - value
    """
    self.send_init_set_property(sess_hdl, dev_id, property, value)
    self.recv_init_set_property()

  def send_init_set_property(self, sess_hdl, dev_id, property, value):
    self._oprot.writeMessageBegin('init_set_property', TMessageType.CALL, self._seqid)
    args = init_set_property_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_set_property(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = init_set_property_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def hash_fields_register(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_hash_fields_register(sess_hdl, dev_id)
    self.recv_hash_fields_register()

  def send_hash_fields_register(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('hash_fields_register', TMessageType.CALL, self._seqid)
    args = hash_fields_register_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_hash_fields_register(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = hash_fields_register_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def hash_fields_deregister(self, sess_hdl, dev_id):
    """
    Parameters:
     - sess_hdl
     - dev_id
    """
    self.send_hash_fields_deregister(sess_hdl, dev_id)
    self.recv_hash_fields_deregister()

  def send_hash_fields_deregister(self, sess_hdl, dev_id):
    self._oprot.writeMessageBegin('hash_fields_deregister', TMessageType.CALL, self._seqid)
    args = hash_fields_deregister_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_hash_fields_deregister(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = hash_fields_deregister_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def hash_fields_get_digest(self, sess_hdl):
    """
    Parameters:
     - sess_hdl
    """
    self.send_hash_fields_get_digest(sess_hdl)
    return self.recv_hash_fields_get_digest()

  def send_hash_fields_get_digest(self, sess_hdl):
    self._oprot.writeMessageBegin('hash_fields_get_digest', TMessageType.CALL, self._seqid)
    args = hash_fields_get_digest_args()
    args.sess_hdl = sess_hdl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_hash_fields_get_digest(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = hash_fields_get_digest_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "hash_fields_get_digest failed: unknown result");

  def hash_fields_digest_notify_ack(self, sess_hdl, msg_ptr):
    """
    Parameters:
     - sess_hdl
     - msg_ptr
    """
    self.send_hash_fields_digest_notify_ack(sess_hdl, msg_ptr)
    self.recv_hash_fields_digest_notify_ack()

  def send_hash_fields_digest_notify_ack(self, sess_hdl, msg_ptr):
    self._oprot.writeMessageBegin('hash_fields_digest_notify_ack', TMessageType.CALL, self._seqid)
    args = hash_fields_digest_notify_ack_args()
    args.sess_hdl = sess_hdl
    args.msg_ptr = msg_ptr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_hash_fields_digest_notify_ack(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = hash_fields_digest_notify_ack_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def set_learning_timeout(self, sess_hdl, dev_id, usecs):
    """
    Parameters:
     - sess_hdl
     - dev_id
     - usecs
    """
    self.send_set_learning_timeout(sess_hdl, dev_id, usecs)
    self.recv_set_learning_timeout()

  def send_set_learning_timeout(self, sess_hdl, dev_id, usecs):
    self._oprot.writeMessageBegin('set_learning_timeout', TMessageType.CALL, self._seqid)
    args = set_learning_timeout_args()
    args.sess_hdl = sess_hdl
    args.dev_id = dev_id
    args.usecs = usecs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_learning_timeout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_learning_timeout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
    """
    Parameters:
     - dev_tgt
     - tbl_name
     - type
    """
    self.send_tbl_dbg_counter_type_set(dev_tgt, tbl_name, type)
    self.recv_tbl_dbg_counter_type_set()

  def send_tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
    self._oprot.writeMessageBegin('tbl_dbg_counter_type_set', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_type_set_args()
    args.dev_tgt = dev_tgt
    args.tbl_name = tbl_name
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_type_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_type_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tbl_dbg_counter_get(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    self.send_tbl_dbg_counter_get(dev_tgt, tbl_name)
    return self.recv_tbl_dbg_counter_get()

  def send_tbl_dbg_counter_get(self, dev_tgt, tbl_name):
    self._oprot.writeMessageBegin('tbl_dbg_counter_get', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_get_args()
    args.dev_tgt = dev_tgt
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_get(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_get_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_get failed: unknown result");

  def tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
    """
    Parameters:
     - dev_tgt
     - tbl_name
    """
    self.send_tbl_dbg_counter_clear(dev_tgt, tbl_name)
    self.recv_tbl_dbg_counter_clear()

  def send_tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
    self._oprot.writeMessageBegin('tbl_dbg_counter_clear', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_clear_args()
    args.dev_tgt = dev_tgt
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_clear(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_clear_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
    """
    Parameters:
     - dev_tgt
     - stage
     - type
    """
    self.send_tbl_dbg_counter_type_stage_set(dev_tgt, stage, type)
    self.recv_tbl_dbg_counter_type_stage_set()

  def send_tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
    self._oprot.writeMessageBegin('tbl_dbg_counter_type_stage_set', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_type_stage_set_args()
    args.dev_tgt = dev_tgt
    args.stage = stage
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_type_stage_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_type_stage_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
    """
    Parameters:
     - dev_tgt
     - stage
    """
    self.send_tbl_dbg_counter_stage_clear(dev_tgt, stage)
    self.recv_tbl_dbg_counter_stage_clear()

  def send_tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
    self._oprot.writeMessageBegin('tbl_dbg_counter_stage_clear', TMessageType.CALL, self._seqid)
    args = tbl_dbg_counter_stage_clear_args()
    args.dev_tgt = dev_tgt
    args.stage = stage
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tbl_dbg_counter_stage_clear(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tbl_dbg_counter_stage_clear_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
    """
    Parameters:
     - dev_tgt
     - start_stage
     - end_stage
     - direction
    """
    self.send_snapshot_create(dev_tgt, start_stage, end_stage, direction)
    return self.recv_snapshot_create()

  def send_snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
    self._oprot.writeMessageBegin('snapshot_create', TMessageType.CALL, self._seqid)
    args = snapshot_create_args()
    args.dev_tgt = dev_tgt
    args.start_stage = start_stage
    args.end_stage = end_stage
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_create failed: unknown result");

  def snapshot_delete(self, handle):
    """
    Parameters:
     - handle
    """
    self.send_snapshot_delete(handle)
    self.recv_snapshot_delete()

  def send_snapshot_delete(self, handle):
    self._oprot.writeMessageBegin('snapshot_delete', TMessageType.CALL, self._seqid)
    args = snapshot_delete_args()
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def snapshot_state_set(self, handle, state, usecs):
    """
    Parameters:
     - handle
     - state
     - usecs
    """
    self.send_snapshot_state_set(handle, state, usecs)
    self.recv_snapshot_state_set()

  def send_snapshot_state_set(self, handle, state, usecs):
    self._oprot.writeMessageBegin('snapshot_state_set', TMessageType.CALL, self._seqid)
    args = snapshot_state_set_args()
    args.handle = handle
    args.state = state
    args.usecs = usecs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_state_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_state_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def snapshot_state_get(self, handle, pipe):
    """
    Parameters:
     - handle
     - pipe
    """
    self.send_snapshot_state_get(handle, pipe)
    return self.recv_snapshot_state_get()

  def send_snapshot_state_get(self, handle, pipe):
    self._oprot.writeMessageBegin('snapshot_state_get', TMessageType.CALL, self._seqid)
    args = snapshot_state_get_args()
    args.handle = handle
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_state_get(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_state_get_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_state_get failed: unknown result");

  def snapshot_timer_enable(self, handle, disable):
    """
    Parameters:
     - handle
     - disable
    """
    self.send_snapshot_timer_enable(handle, disable)
    self.recv_snapshot_timer_enable()

  def send_snapshot_timer_enable(self, handle, disable):
    self._oprot.writeMessageBegin('snapshot_timer_enable', TMessageType.CALL, self._seqid)
    args = snapshot_timer_enable_args()
    args.handle = handle
    args.disable = disable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_timer_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_timer_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
    """
    Parameters:
     - handle
     - trig_spec
     - trig_spec2
    """
    self.send_snapshot_capture_trigger_set(handle, trig_spec, trig_spec2)
    self.recv_snapshot_capture_trigger_set()

  def send_snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
    self._oprot.writeMessageBegin('snapshot_capture_trigger_set', TMessageType.CALL, self._seqid)
    args = snapshot_capture_trigger_set_args()
    args.handle = handle
    args.trig_spec = trig_spec
    args.trig_spec2 = trig_spec2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_capture_trigger_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_capture_trigger_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
    """
    Parameters:
     - handle
     - pipe
     - stage_id
     - field_name
    """
    self.send_snapshot_capture_data_get(handle, pipe, stage_id, field_name)
    return self.recv_snapshot_capture_data_get()

  def send_snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
    self._oprot.writeMessageBegin('snapshot_capture_data_get', TMessageType.CALL, self._seqid)
    args = snapshot_capture_data_get_args()
    args.handle = handle
    args.pipe = pipe
    args.stage_id = stage_id
    args.field_name = field_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_capture_data_get(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_capture_data_get_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_capture_data_get failed: unknown result");

  def snapshot_field_in_scope(self, dev_tgt, stage, direction, field_name):
    """
    Parameters:
     - dev_tgt
     - stage
     - direction
     - field_name
    """
    self.send_snapshot_field_in_scope(dev_tgt, stage, direction, field_name)
    return self.recv_snapshot_field_in_scope()

  def send_snapshot_field_in_scope(self, dev_tgt, stage, direction, field_name):
    self._oprot.writeMessageBegin('snapshot_field_in_scope', TMessageType.CALL, self._seqid)
    args = snapshot_field_in_scope_args()
    args.dev_tgt = dev_tgt
    args.stage = stage
    args.direction = direction
    args.field_name = field_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_field_in_scope(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_field_in_scope_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_field_in_scope failed: unknown result");

  def register_read_h2_seq(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_register_read_h2_seq(sess_hdl, dev_tgt, index, flags)
    return self.recv_register_read_h2_seq()

  def send_register_read_h2_seq(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('register_read_h2_seq', TMessageType.CALL, self._seqid)
    args = register_read_h2_seq_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_read_h2_seq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_read_h2_seq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "register_read_h2_seq failed: unknown result");

  def register_write_h2_seq(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    self.send_register_write_h2_seq(sess_hdl, dev_tgt, index, register_value)
    self.recv_register_write_h2_seq()

  def send_register_write_h2_seq(self, sess_hdl, dev_tgt, index, register_value):
    self._oprot.writeMessageBegin('register_write_h2_seq', TMessageType.CALL, self._seqid)
    args = register_write_h2_seq_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_h2_seq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_h2_seq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_read_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_register_read_heavy_hitter_counter2(sess_hdl, dev_tgt, index, flags)
    return self.recv_register_read_heavy_hitter_counter2()

  def send_register_read_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('register_read_heavy_hitter_counter2', TMessageType.CALL, self._seqid)
    args = register_read_heavy_hitter_counter2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_read_heavy_hitter_counter2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_read_heavy_hitter_counter2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "register_read_heavy_hitter_counter2 failed: unknown result");

  def register_write_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    self.send_register_write_heavy_hitter_counter2(sess_hdl, dev_tgt, index, register_value)
    self.recv_register_write_heavy_hitter_counter2()

  def send_register_write_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, register_value):
    self._oprot.writeMessageBegin('register_write_heavy_hitter_counter2', TMessageType.CALL, self._seqid)
    args = register_write_heavy_hitter_counter2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_heavy_hitter_counter2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_heavy_hitter_counter2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_read_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_register_read_heavy_hitter_counter1(sess_hdl, dev_tgt, index, flags)
    return self.recv_register_read_heavy_hitter_counter1()

  def send_register_read_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('register_read_heavy_hitter_counter1', TMessageType.CALL, self._seqid)
    args = register_read_heavy_hitter_counter1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_read_heavy_hitter_counter1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_read_heavy_hitter_counter1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "register_read_heavy_hitter_counter1 failed: unknown result");

  def register_write_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    self.send_register_write_heavy_hitter_counter1(sess_hdl, dev_tgt, index, register_value)
    self.recv_register_write_heavy_hitter_counter1()

  def send_register_write_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, register_value):
    self._oprot.writeMessageBegin('register_write_heavy_hitter_counter1', TMessageType.CALL, self._seqid)
    args = register_write_heavy_hitter_counter1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_heavy_hitter_counter1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_heavy_hitter_counter1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_read_write_time_in(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_register_read_write_time_in(sess_hdl, dev_tgt, index, flags)
    return self.recv_register_read_write_time_in()

  def send_register_read_write_time_in(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('register_read_write_time_in', TMessageType.CALL, self._seqid)
    args = register_read_write_time_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_read_write_time_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_read_write_time_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "register_read_write_time_in failed: unknown result");

  def register_write_write_time_in(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    self.send_register_write_write_time_in(sess_hdl, dev_tgt, index, register_value)
    self.recv_register_write_write_time_in()

  def send_register_write_write_time_in(self, sess_hdl, dev_tgt, index, register_value):
    self._oprot.writeMessageBegin('register_write_write_time_in', TMessageType.CALL, self._seqid)
    args = register_write_write_time_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_write_time_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_write_time_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_read_write_time_eg(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_register_read_write_time_eg(sess_hdl, dev_tgt, index, flags)
    return self.recv_register_read_write_time_eg()

  def send_register_read_write_time_eg(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('register_read_write_time_eg', TMessageType.CALL, self._seqid)
    args = register_read_write_time_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_read_write_time_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_read_write_time_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "register_read_write_time_eg failed: unknown result");

  def register_write_write_time_eg(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    self.send_register_write_write_time_eg(sess_hdl, dev_tgt, index, register_value)
    self.recv_register_write_write_time_eg()

  def send_register_write_write_time_eg(self, sess_hdl, dev_tgt, index, register_value):
    self._oprot.writeMessageBegin('register_write_write_time_eg', TMessageType.CALL, self._seqid)
    args = register_write_write_time_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_write_time_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_write_time_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_read_countt(self, sess_hdl, dev_tgt, index, flags):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - flags
    """
    self.send_register_read_countt(sess_hdl, dev_tgt, index, flags)
    return self.recv_register_read_countt()

  def send_register_read_countt(self, sess_hdl, dev_tgt, index, flags):
    self._oprot.writeMessageBegin('register_read_countt', TMessageType.CALL, self._seqid)
    args = register_read_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.flags = flags
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_read_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_read_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "register_read_countt failed: unknown result");

  def register_write_countt(self, sess_hdl, dev_tgt, index, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - register_value
    """
    self.send_register_write_countt(sess_hdl, dev_tgt, index, register_value)
    self.recv_register_write_countt()

  def send_register_write_countt(self, sess_hdl, dev_tgt, index, register_value):
    self._oprot.writeMessageBegin('register_write_countt', TMessageType.CALL, self._seqid)
    args = register_write_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_hw_sync_h2_seq(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_hw_sync_h2_seq(sess_hdl, dev_tgt)
    self.recv_register_hw_sync_h2_seq()

  def send_register_hw_sync_h2_seq(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_hw_sync_h2_seq', TMessageType.CALL, self._seqid)
    args = register_hw_sync_h2_seq_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_hw_sync_h2_seq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_hw_sync_h2_seq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_reset_all_h2_seq(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_reset_all_h2_seq(sess_hdl, dev_tgt)
    self.recv_register_reset_all_h2_seq()

  def send_register_reset_all_h2_seq(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_reset_all_h2_seq', TMessageType.CALL, self._seqid)
    args = register_reset_all_h2_seq_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_reset_all_h2_seq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_reset_all_h2_seq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_range_reset_h2_seq(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    self.send_register_range_reset_h2_seq(sess_hdl, dev_tgt, index, count)
    self.recv_register_range_reset_h2_seq()

  def send_register_range_reset_h2_seq(self, sess_hdl, dev_tgt, index, count):
    self._oprot.writeMessageBegin('register_range_reset_h2_seq', TMessageType.CALL, self._seqid)
    args = register_range_reset_h2_seq_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_range_reset_h2_seq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_range_reset_h2_seq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_write_all_h2_seq(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    self.send_register_write_all_h2_seq(sess_hdl, dev_tgt, register_value)
    self.recv_register_write_all_h2_seq()

  def send_register_write_all_h2_seq(self, sess_hdl, dev_tgt, register_value):
    self._oprot.writeMessageBegin('register_write_all_h2_seq', TMessageType.CALL, self._seqid)
    args = register_write_all_h2_seq_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_all_h2_seq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_all_h2_seq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_hw_sync_heavy_hitter_counter2(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_hw_sync_heavy_hitter_counter2(sess_hdl, dev_tgt)
    self.recv_register_hw_sync_heavy_hitter_counter2()

  def send_register_hw_sync_heavy_hitter_counter2(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_hw_sync_heavy_hitter_counter2', TMessageType.CALL, self._seqid)
    args = register_hw_sync_heavy_hitter_counter2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_hw_sync_heavy_hitter_counter2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_hw_sync_heavy_hitter_counter2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_reset_all_heavy_hitter_counter2(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_reset_all_heavy_hitter_counter2(sess_hdl, dev_tgt)
    self.recv_register_reset_all_heavy_hitter_counter2()

  def send_register_reset_all_heavy_hitter_counter2(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_reset_all_heavy_hitter_counter2', TMessageType.CALL, self._seqid)
    args = register_reset_all_heavy_hitter_counter2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_reset_all_heavy_hitter_counter2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_reset_all_heavy_hitter_counter2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_range_reset_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    self.send_register_range_reset_heavy_hitter_counter2(sess_hdl, dev_tgt, index, count)
    self.recv_register_range_reset_heavy_hitter_counter2()

  def send_register_range_reset_heavy_hitter_counter2(self, sess_hdl, dev_tgt, index, count):
    self._oprot.writeMessageBegin('register_range_reset_heavy_hitter_counter2', TMessageType.CALL, self._seqid)
    args = register_range_reset_heavy_hitter_counter2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_range_reset_heavy_hitter_counter2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_range_reset_heavy_hitter_counter2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_write_all_heavy_hitter_counter2(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    self.send_register_write_all_heavy_hitter_counter2(sess_hdl, dev_tgt, register_value)
    self.recv_register_write_all_heavy_hitter_counter2()

  def send_register_write_all_heavy_hitter_counter2(self, sess_hdl, dev_tgt, register_value):
    self._oprot.writeMessageBegin('register_write_all_heavy_hitter_counter2', TMessageType.CALL, self._seqid)
    args = register_write_all_heavy_hitter_counter2_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_all_heavy_hitter_counter2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_all_heavy_hitter_counter2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_hw_sync_heavy_hitter_counter1(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_hw_sync_heavy_hitter_counter1(sess_hdl, dev_tgt)
    self.recv_register_hw_sync_heavy_hitter_counter1()

  def send_register_hw_sync_heavy_hitter_counter1(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_hw_sync_heavy_hitter_counter1', TMessageType.CALL, self._seqid)
    args = register_hw_sync_heavy_hitter_counter1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_hw_sync_heavy_hitter_counter1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_hw_sync_heavy_hitter_counter1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_reset_all_heavy_hitter_counter1(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_reset_all_heavy_hitter_counter1(sess_hdl, dev_tgt)
    self.recv_register_reset_all_heavy_hitter_counter1()

  def send_register_reset_all_heavy_hitter_counter1(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_reset_all_heavy_hitter_counter1', TMessageType.CALL, self._seqid)
    args = register_reset_all_heavy_hitter_counter1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_reset_all_heavy_hitter_counter1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_reset_all_heavy_hitter_counter1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_range_reset_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    self.send_register_range_reset_heavy_hitter_counter1(sess_hdl, dev_tgt, index, count)
    self.recv_register_range_reset_heavy_hitter_counter1()

  def send_register_range_reset_heavy_hitter_counter1(self, sess_hdl, dev_tgt, index, count):
    self._oprot.writeMessageBegin('register_range_reset_heavy_hitter_counter1', TMessageType.CALL, self._seqid)
    args = register_range_reset_heavy_hitter_counter1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_range_reset_heavy_hitter_counter1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_range_reset_heavy_hitter_counter1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_write_all_heavy_hitter_counter1(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    self.send_register_write_all_heavy_hitter_counter1(sess_hdl, dev_tgt, register_value)
    self.recv_register_write_all_heavy_hitter_counter1()

  def send_register_write_all_heavy_hitter_counter1(self, sess_hdl, dev_tgt, register_value):
    self._oprot.writeMessageBegin('register_write_all_heavy_hitter_counter1', TMessageType.CALL, self._seqid)
    args = register_write_all_heavy_hitter_counter1_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_all_heavy_hitter_counter1(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_all_heavy_hitter_counter1_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_hw_sync_write_time_in(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_hw_sync_write_time_in(sess_hdl, dev_tgt)
    self.recv_register_hw_sync_write_time_in()

  def send_register_hw_sync_write_time_in(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_hw_sync_write_time_in', TMessageType.CALL, self._seqid)
    args = register_hw_sync_write_time_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_hw_sync_write_time_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_hw_sync_write_time_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_reset_all_write_time_in(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_reset_all_write_time_in(sess_hdl, dev_tgt)
    self.recv_register_reset_all_write_time_in()

  def send_register_reset_all_write_time_in(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_reset_all_write_time_in', TMessageType.CALL, self._seqid)
    args = register_reset_all_write_time_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_reset_all_write_time_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_reset_all_write_time_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_range_reset_write_time_in(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    self.send_register_range_reset_write_time_in(sess_hdl, dev_tgt, index, count)
    self.recv_register_range_reset_write_time_in()

  def send_register_range_reset_write_time_in(self, sess_hdl, dev_tgt, index, count):
    self._oprot.writeMessageBegin('register_range_reset_write_time_in', TMessageType.CALL, self._seqid)
    args = register_range_reset_write_time_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_range_reset_write_time_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_range_reset_write_time_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_write_all_write_time_in(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    self.send_register_write_all_write_time_in(sess_hdl, dev_tgt, register_value)
    self.recv_register_write_all_write_time_in()

  def send_register_write_all_write_time_in(self, sess_hdl, dev_tgt, register_value):
    self._oprot.writeMessageBegin('register_write_all_write_time_in', TMessageType.CALL, self._seqid)
    args = register_write_all_write_time_in_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_all_write_time_in(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_all_write_time_in_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_hw_sync_write_time_eg(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_hw_sync_write_time_eg(sess_hdl, dev_tgt)
    self.recv_register_hw_sync_write_time_eg()

  def send_register_hw_sync_write_time_eg(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_hw_sync_write_time_eg', TMessageType.CALL, self._seqid)
    args = register_hw_sync_write_time_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_hw_sync_write_time_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_hw_sync_write_time_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_reset_all_write_time_eg(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_reset_all_write_time_eg(sess_hdl, dev_tgt)
    self.recv_register_reset_all_write_time_eg()

  def send_register_reset_all_write_time_eg(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_reset_all_write_time_eg', TMessageType.CALL, self._seqid)
    args = register_reset_all_write_time_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_reset_all_write_time_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_reset_all_write_time_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_range_reset_write_time_eg(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    self.send_register_range_reset_write_time_eg(sess_hdl, dev_tgt, index, count)
    self.recv_register_range_reset_write_time_eg()

  def send_register_range_reset_write_time_eg(self, sess_hdl, dev_tgt, index, count):
    self._oprot.writeMessageBegin('register_range_reset_write_time_eg', TMessageType.CALL, self._seqid)
    args = register_range_reset_write_time_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_range_reset_write_time_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_range_reset_write_time_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_write_all_write_time_eg(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    self.send_register_write_all_write_time_eg(sess_hdl, dev_tgt, register_value)
    self.recv_register_write_all_write_time_eg()

  def send_register_write_all_write_time_eg(self, sess_hdl, dev_tgt, register_value):
    self._oprot.writeMessageBegin('register_write_all_write_time_eg', TMessageType.CALL, self._seqid)
    args = register_write_all_write_time_eg_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_all_write_time_eg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_all_write_time_eg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_hw_sync_countt(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_hw_sync_countt(sess_hdl, dev_tgt)
    self.recv_register_hw_sync_countt()

  def send_register_hw_sync_countt(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_hw_sync_countt', TMessageType.CALL, self._seqid)
    args = register_hw_sync_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_hw_sync_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_hw_sync_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_reset_all_countt(self, sess_hdl, dev_tgt):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
    """
    self.send_register_reset_all_countt(sess_hdl, dev_tgt)
    self.recv_register_reset_all_countt()

  def send_register_reset_all_countt(self, sess_hdl, dev_tgt):
    self._oprot.writeMessageBegin('register_reset_all_countt', TMessageType.CALL, self._seqid)
    args = register_reset_all_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_reset_all_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_reset_all_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_range_reset_countt(self, sess_hdl, dev_tgt, index, count):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - index
     - count
    """
    self.send_register_range_reset_countt(sess_hdl, dev_tgt, index, count)
    self.recv_register_range_reset_countt()

  def send_register_range_reset_countt(self, sess_hdl, dev_tgt, index, count):
    self._oprot.writeMessageBegin('register_range_reset_countt', TMessageType.CALL, self._seqid)
    args = register_range_reset_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.index = index
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_range_reset_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_range_reset_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def register_write_all_countt(self, sess_hdl, dev_tgt, register_value):
    """
    Parameters:
     - sess_hdl
     - dev_tgt
     - register_value
    """
    self.send_register_write_all_countt(sess_hdl, dev_tgt, register_value)
    self.recv_register_write_all_countt()

  def send_register_write_all_countt(self, sess_hdl, dev_tgt, register_value):
    self._oprot.writeMessageBegin('register_write_all_countt', TMessageType.CALL, self._seqid)
    args = register_write_all_countt_args()
    args.sess_hdl = sess_hdl
    args.dev_tgt = dev_tgt
    args.register_value = register_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_write_all_countt(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = register_write_all_countt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["acl_match_spec_to_entry_hdl"] = Processor.process_acl_match_spec_to_entry_hdl
    self._processMap["acl_table_add_with___meta_init_miss_action_acl__"] = Processor.process_acl_table_add_with___meta_init_miss_action_acl__
    self._processMap["acl_table_add_with_nop"] = Processor.process_acl_table_add_with_nop
    self._processMap["acl_table_add_with__drop"] = Processor.process_acl_table_add_with__drop
    self._processMap["acl_table_modify_with___meta_init_miss_action_acl__"] = Processor.process_acl_table_modify_with___meta_init_miss_action_acl__
    self._processMap["acl_table_modify_with___meta_init_miss_action_acl___by_match_spec"] = Processor.process_acl_table_modify_with___meta_init_miss_action_acl___by_match_spec
    self._processMap["acl_table_modify_with_nop"] = Processor.process_acl_table_modify_with_nop
    self._processMap["acl_table_modify_with_nop_by_match_spec"] = Processor.process_acl_table_modify_with_nop_by_match_spec
    self._processMap["acl_table_modify_with__drop"] = Processor.process_acl_table_modify_with__drop
    self._processMap["acl_table_modify_with__drop_by_match_spec"] = Processor.process_acl_table_modify_with__drop_by_match_spec
    self._processMap["acl_table_delete"] = Processor.process_acl_table_delete
    self._processMap["acl_table_delete_by_match_spec"] = Processor.process_acl_table_delete_by_match_spec
    self._processMap["update_countt_table_reset_default_entry"] = Processor.process_update_countt_table_reset_default_entry
    self._processMap["time32_in_table_reset_default_entry"] = Processor.process_time32_in_table_reset_default_entry
    self._processMap["write_time_in_table_reset_default_entry"] = Processor.process_write_time_in_table_reset_default_entry
    self._processMap["time32_eg_table_reset_default_entry"] = Processor.process_time32_eg_table_reset_default_entry
    self._processMap["write_time_eg_table_reset_default_entry"] = Processor.process_write_time_eg_table_reset_default_entry
    self._processMap["session_check_table_reset_default_entry"] = Processor.process_session_check_table_reset_default_entry
    self._processMap["session_check_reverse_table_reset_default_entry"] = Processor.process_session_check_reverse_table_reset_default_entry
    self._processMap["read_seq_table_reset_default_entry"] = Processor.process_read_seq_table_reset_default_entry
    self._processMap["read_seq_reverse_table_reset_default_entry"] = Processor.process_read_seq_reverse_table_reset_default_entry
    self._processMap["write_seq_table_reset_default_entry"] = Processor.process_write_seq_table_reset_default_entry
    self._processMap["session_init_table_table_reset_default_entry"] = Processor.process_session_init_table_table_reset_default_entry
    self._processMap["session_complete_table_table_reset_default_entry"] = Processor.process_session_complete_table_table_reset_default_entry
    self._processMap["relay_session_table_table_reset_default_entry"] = Processor.process_relay_session_table_table_reset_default_entry
    self._processMap["inbound_tran_table_table_reset_default_entry"] = Processor.process_inbound_tran_table_table_reset_default_entry
    self._processMap["outbound_tran_table_table_reset_default_entry"] = Processor.process_outbound_tran_table_table_reset_default_entry
    self._processMap["report_table_table_reset_default_entry"] = Processor.process_report_table_table_reset_default_entry
    self._processMap["set_heavy_hitter_count_table_1_table_reset_default_entry"] = Processor.process_set_heavy_hitter_count_table_1_table_reset_default_entry
    self._processMap["set_heavy_hitter_count_table_2_table_reset_default_entry"] = Processor.process_set_heavy_hitter_count_table_2_table_reset_default_entry
    self._processMap["acl_table_reset_default_entry"] = Processor.process_acl_table_reset_default_entry
    self._processMap["init_table_reset_default_entry"] = Processor.process_init_table_reset_default_entry
    self._processMap["update_countt_get_entry_count"] = Processor.process_update_countt_get_entry_count
    self._processMap["time32_in_get_entry_count"] = Processor.process_time32_in_get_entry_count
    self._processMap["write_time_in_get_entry_count"] = Processor.process_write_time_in_get_entry_count
    self._processMap["time32_eg_get_entry_count"] = Processor.process_time32_eg_get_entry_count
    self._processMap["write_time_eg_get_entry_count"] = Processor.process_write_time_eg_get_entry_count
    self._processMap["session_check_get_entry_count"] = Processor.process_session_check_get_entry_count
    self._processMap["session_check_reverse_get_entry_count"] = Processor.process_session_check_reverse_get_entry_count
    self._processMap["read_seq_get_entry_count"] = Processor.process_read_seq_get_entry_count
    self._processMap["read_seq_reverse_get_entry_count"] = Processor.process_read_seq_reverse_get_entry_count
    self._processMap["write_seq_get_entry_count"] = Processor.process_write_seq_get_entry_count
    self._processMap["session_init_table_get_entry_count"] = Processor.process_session_init_table_get_entry_count
    self._processMap["session_complete_table_get_entry_count"] = Processor.process_session_complete_table_get_entry_count
    self._processMap["relay_session_table_get_entry_count"] = Processor.process_relay_session_table_get_entry_count
    self._processMap["inbound_tran_table_get_entry_count"] = Processor.process_inbound_tran_table_get_entry_count
    self._processMap["outbound_tran_table_get_entry_count"] = Processor.process_outbound_tran_table_get_entry_count
    self._processMap["report_table_get_entry_count"] = Processor.process_report_table_get_entry_count
    self._processMap["set_heavy_hitter_count_table_1_get_entry_count"] = Processor.process_set_heavy_hitter_count_table_1_get_entry_count
    self._processMap["set_heavy_hitter_count_table_2_get_entry_count"] = Processor.process_set_heavy_hitter_count_table_2_get_entry_count
    self._processMap["acl_get_entry_count"] = Processor.process_acl_get_entry_count
    self._processMap["init_get_entry_count"] = Processor.process_init_get_entry_count
    self._processMap["update_countt_get_first_entry_handle"] = Processor.process_update_countt_get_first_entry_handle
    self._processMap["update_countt_get_next_entry_handles"] = Processor.process_update_countt_get_next_entry_handles
    self._processMap["update_countt_get_entry"] = Processor.process_update_countt_get_entry
    self._processMap["time32_in_get_first_entry_handle"] = Processor.process_time32_in_get_first_entry_handle
    self._processMap["time32_in_get_next_entry_handles"] = Processor.process_time32_in_get_next_entry_handles
    self._processMap["time32_in_get_entry"] = Processor.process_time32_in_get_entry
    self._processMap["write_time_in_get_first_entry_handle"] = Processor.process_write_time_in_get_first_entry_handle
    self._processMap["write_time_in_get_next_entry_handles"] = Processor.process_write_time_in_get_next_entry_handles
    self._processMap["write_time_in_get_entry"] = Processor.process_write_time_in_get_entry
    self._processMap["time32_eg_get_first_entry_handle"] = Processor.process_time32_eg_get_first_entry_handle
    self._processMap["time32_eg_get_next_entry_handles"] = Processor.process_time32_eg_get_next_entry_handles
    self._processMap["time32_eg_get_entry"] = Processor.process_time32_eg_get_entry
    self._processMap["write_time_eg_get_first_entry_handle"] = Processor.process_write_time_eg_get_first_entry_handle
    self._processMap["write_time_eg_get_next_entry_handles"] = Processor.process_write_time_eg_get_next_entry_handles
    self._processMap["write_time_eg_get_entry"] = Processor.process_write_time_eg_get_entry
    self._processMap["session_check_get_first_entry_handle"] = Processor.process_session_check_get_first_entry_handle
    self._processMap["session_check_get_next_entry_handles"] = Processor.process_session_check_get_next_entry_handles
    self._processMap["session_check_get_entry"] = Processor.process_session_check_get_entry
    self._processMap["session_check_reverse_get_first_entry_handle"] = Processor.process_session_check_reverse_get_first_entry_handle
    self._processMap["session_check_reverse_get_next_entry_handles"] = Processor.process_session_check_reverse_get_next_entry_handles
    self._processMap["session_check_reverse_get_entry"] = Processor.process_session_check_reverse_get_entry
    self._processMap["read_seq_get_first_entry_handle"] = Processor.process_read_seq_get_first_entry_handle
    self._processMap["read_seq_get_next_entry_handles"] = Processor.process_read_seq_get_next_entry_handles
    self._processMap["read_seq_get_entry"] = Processor.process_read_seq_get_entry
    self._processMap["read_seq_reverse_get_first_entry_handle"] = Processor.process_read_seq_reverse_get_first_entry_handle
    self._processMap["read_seq_reverse_get_next_entry_handles"] = Processor.process_read_seq_reverse_get_next_entry_handles
    self._processMap["read_seq_reverse_get_entry"] = Processor.process_read_seq_reverse_get_entry
    self._processMap["write_seq_get_first_entry_handle"] = Processor.process_write_seq_get_first_entry_handle
    self._processMap["write_seq_get_next_entry_handles"] = Processor.process_write_seq_get_next_entry_handles
    self._processMap["write_seq_get_entry"] = Processor.process_write_seq_get_entry
    self._processMap["session_init_table_get_first_entry_handle"] = Processor.process_session_init_table_get_first_entry_handle
    self._processMap["session_init_table_get_next_entry_handles"] = Processor.process_session_init_table_get_next_entry_handles
    self._processMap["session_init_table_get_entry"] = Processor.process_session_init_table_get_entry
    self._processMap["session_complete_table_get_first_entry_handle"] = Processor.process_session_complete_table_get_first_entry_handle
    self._processMap["session_complete_table_get_next_entry_handles"] = Processor.process_session_complete_table_get_next_entry_handles
    self._processMap["session_complete_table_get_entry"] = Processor.process_session_complete_table_get_entry
    self._processMap["relay_session_table_get_first_entry_handle"] = Processor.process_relay_session_table_get_first_entry_handle
    self._processMap["relay_session_table_get_next_entry_handles"] = Processor.process_relay_session_table_get_next_entry_handles
    self._processMap["relay_session_table_get_entry"] = Processor.process_relay_session_table_get_entry
    self._processMap["inbound_tran_table_get_first_entry_handle"] = Processor.process_inbound_tran_table_get_first_entry_handle
    self._processMap["inbound_tran_table_get_next_entry_handles"] = Processor.process_inbound_tran_table_get_next_entry_handles
    self._processMap["inbound_tran_table_get_entry"] = Processor.process_inbound_tran_table_get_entry
    self._processMap["outbound_tran_table_get_first_entry_handle"] = Processor.process_outbound_tran_table_get_first_entry_handle
    self._processMap["outbound_tran_table_get_next_entry_handles"] = Processor.process_outbound_tran_table_get_next_entry_handles
    self._processMap["outbound_tran_table_get_entry"] = Processor.process_outbound_tran_table_get_entry
    self._processMap["report_table_get_first_entry_handle"] = Processor.process_report_table_get_first_entry_handle
    self._processMap["report_table_get_next_entry_handles"] = Processor.process_report_table_get_next_entry_handles
    self._processMap["report_table_get_entry"] = Processor.process_report_table_get_entry
    self._processMap["set_heavy_hitter_count_table_1_get_first_entry_handle"] = Processor.process_set_heavy_hitter_count_table_1_get_first_entry_handle
    self._processMap["set_heavy_hitter_count_table_1_get_next_entry_handles"] = Processor.process_set_heavy_hitter_count_table_1_get_next_entry_handles
    self._processMap["set_heavy_hitter_count_table_1_get_entry"] = Processor.process_set_heavy_hitter_count_table_1_get_entry
    self._processMap["set_heavy_hitter_count_table_2_get_first_entry_handle"] = Processor.process_set_heavy_hitter_count_table_2_get_first_entry_handle
    self._processMap["set_heavy_hitter_count_table_2_get_next_entry_handles"] = Processor.process_set_heavy_hitter_count_table_2_get_next_entry_handles
    self._processMap["set_heavy_hitter_count_table_2_get_entry"] = Processor.process_set_heavy_hitter_count_table_2_get_entry
    self._processMap["acl_get_first_entry_handle"] = Processor.process_acl_get_first_entry_handle
    self._processMap["acl_get_next_entry_handles"] = Processor.process_acl_get_next_entry_handles
    self._processMap["acl_get_entry"] = Processor.process_acl_get_entry
    self._processMap["init_get_first_entry_handle"] = Processor.process_init_get_first_entry_handle
    self._processMap["init_get_next_entry_handles"] = Processor.process_init_get_next_entry_handles
    self._processMap["init_get_entry"] = Processor.process_init_get_entry
    self._processMap["update_countt_set_default_action_update_countt"] = Processor.process_update_countt_set_default_action_update_countt
    self._processMap["time32_in_set_default_action_time32_in"] = Processor.process_time32_in_set_default_action_time32_in
    self._processMap["time32_eg_set_default_action_time32_eg"] = Processor.process_time32_eg_set_default_action_time32_eg
    self._processMap["session_check_set_default_action_lookup_session_map"] = Processor.process_session_check_set_default_action_lookup_session_map
    self._processMap["session_check_reverse_set_default_action_lookup_session_map_reverse"] = Processor.process_session_check_reverse_set_default_action_lookup_session_map_reverse
    self._processMap["session_init_table_set_default_action_sendback_sa"] = Processor.process_session_init_table_set_default_action_sendback_sa
    self._processMap["session_complete_table_set_default_action_sendh2syn"] = Processor.process_session_complete_table_set_default_action_sendh2syn
    self._processMap["relay_session_table_set_default_action_sendh2ack"] = Processor.process_relay_session_table_set_default_action_sendh2ack
    self._processMap["inbound_tran_table_set_default_action_inbound_transformation"] = Processor.process_inbound_tran_table_set_default_action_inbound_transformation
    self._processMap["outbound_tran_table_set_default_action_outbound_transformation"] = Processor.process_outbound_tran_table_set_default_action_outbound_transformation
    self._processMap["report_table_set_default_action_report"] = Processor.process_report_table_set_default_action_report
    self._processMap["set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1"] = Processor.process_set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1
    self._processMap["set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2"] = Processor.process_set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2
    self._processMap["acl_set_default_action___meta_init_miss_action_acl__"] = Processor.process_acl_set_default_action___meta_init_miss_action_acl__
    self._processMap["acl_set_default_action_nop"] = Processor.process_acl_set_default_action_nop
    self._processMap["acl_set_default_action__drop"] = Processor.process_acl_set_default_action__drop
    self._processMap["init_set_default_action_init_action"] = Processor.process_init_set_default_action_init_action
    self._processMap["update_countt_set_property"] = Processor.process_update_countt_set_property
    self._processMap["time32_in_set_property"] = Processor.process_time32_in_set_property
    self._processMap["write_time_in_set_property"] = Processor.process_write_time_in_set_property
    self._processMap["time32_eg_set_property"] = Processor.process_time32_eg_set_property
    self._processMap["write_time_eg_set_property"] = Processor.process_write_time_eg_set_property
    self._processMap["session_check_set_property"] = Processor.process_session_check_set_property
    self._processMap["session_check_reverse_set_property"] = Processor.process_session_check_reverse_set_property
    self._processMap["read_seq_set_property"] = Processor.process_read_seq_set_property
    self._processMap["read_seq_reverse_set_property"] = Processor.process_read_seq_reverse_set_property
    self._processMap["write_seq_set_property"] = Processor.process_write_seq_set_property
    self._processMap["session_init_table_set_property"] = Processor.process_session_init_table_set_property
    self._processMap["session_complete_table_set_property"] = Processor.process_session_complete_table_set_property
    self._processMap["relay_session_table_set_property"] = Processor.process_relay_session_table_set_property
    self._processMap["inbound_tran_table_set_property"] = Processor.process_inbound_tran_table_set_property
    self._processMap["outbound_tran_table_set_property"] = Processor.process_outbound_tran_table_set_property
    self._processMap["report_table_set_property"] = Processor.process_report_table_set_property
    self._processMap["set_heavy_hitter_count_table_1_set_property"] = Processor.process_set_heavy_hitter_count_table_1_set_property
    self._processMap["set_heavy_hitter_count_table_2_set_property"] = Processor.process_set_heavy_hitter_count_table_2_set_property
    self._processMap["acl_set_property"] = Processor.process_acl_set_property
    self._processMap["init_set_property"] = Processor.process_init_set_property
    self._processMap["hash_fields_register"] = Processor.process_hash_fields_register
    self._processMap["hash_fields_deregister"] = Processor.process_hash_fields_deregister
    self._processMap["hash_fields_get_digest"] = Processor.process_hash_fields_get_digest
    self._processMap["hash_fields_digest_notify_ack"] = Processor.process_hash_fields_digest_notify_ack
    self._processMap["set_learning_timeout"] = Processor.process_set_learning_timeout
    self._processMap["tbl_dbg_counter_type_set"] = Processor.process_tbl_dbg_counter_type_set
    self._processMap["tbl_dbg_counter_get"] = Processor.process_tbl_dbg_counter_get
    self._processMap["tbl_dbg_counter_clear"] = Processor.process_tbl_dbg_counter_clear
    self._processMap["tbl_dbg_counter_type_stage_set"] = Processor.process_tbl_dbg_counter_type_stage_set
    self._processMap["tbl_dbg_counter_stage_clear"] = Processor.process_tbl_dbg_counter_stage_clear
    self._processMap["snapshot_create"] = Processor.process_snapshot_create
    self._processMap["snapshot_delete"] = Processor.process_snapshot_delete
    self._processMap["snapshot_state_set"] = Processor.process_snapshot_state_set
    self._processMap["snapshot_state_get"] = Processor.process_snapshot_state_get
    self._processMap["snapshot_timer_enable"] = Processor.process_snapshot_timer_enable
    self._processMap["snapshot_capture_trigger_set"] = Processor.process_snapshot_capture_trigger_set
    self._processMap["snapshot_capture_data_get"] = Processor.process_snapshot_capture_data_get
    self._processMap["snapshot_field_in_scope"] = Processor.process_snapshot_field_in_scope
    self._processMap["register_read_h2_seq"] = Processor.process_register_read_h2_seq
    self._processMap["register_write_h2_seq"] = Processor.process_register_write_h2_seq
    self._processMap["register_read_heavy_hitter_counter2"] = Processor.process_register_read_heavy_hitter_counter2
    self._processMap["register_write_heavy_hitter_counter2"] = Processor.process_register_write_heavy_hitter_counter2
    self._processMap["register_read_heavy_hitter_counter1"] = Processor.process_register_read_heavy_hitter_counter1
    self._processMap["register_write_heavy_hitter_counter1"] = Processor.process_register_write_heavy_hitter_counter1
    self._processMap["register_read_write_time_in"] = Processor.process_register_read_write_time_in
    self._processMap["register_write_write_time_in"] = Processor.process_register_write_write_time_in
    self._processMap["register_read_write_time_eg"] = Processor.process_register_read_write_time_eg
    self._processMap["register_write_write_time_eg"] = Processor.process_register_write_write_time_eg
    self._processMap["register_read_countt"] = Processor.process_register_read_countt
    self._processMap["register_write_countt"] = Processor.process_register_write_countt
    self._processMap["register_hw_sync_h2_seq"] = Processor.process_register_hw_sync_h2_seq
    self._processMap["register_reset_all_h2_seq"] = Processor.process_register_reset_all_h2_seq
    self._processMap["register_range_reset_h2_seq"] = Processor.process_register_range_reset_h2_seq
    self._processMap["register_write_all_h2_seq"] = Processor.process_register_write_all_h2_seq
    self._processMap["register_hw_sync_heavy_hitter_counter2"] = Processor.process_register_hw_sync_heavy_hitter_counter2
    self._processMap["register_reset_all_heavy_hitter_counter2"] = Processor.process_register_reset_all_heavy_hitter_counter2
    self._processMap["register_range_reset_heavy_hitter_counter2"] = Processor.process_register_range_reset_heavy_hitter_counter2
    self._processMap["register_write_all_heavy_hitter_counter2"] = Processor.process_register_write_all_heavy_hitter_counter2
    self._processMap["register_hw_sync_heavy_hitter_counter1"] = Processor.process_register_hw_sync_heavy_hitter_counter1
    self._processMap["register_reset_all_heavy_hitter_counter1"] = Processor.process_register_reset_all_heavy_hitter_counter1
    self._processMap["register_range_reset_heavy_hitter_counter1"] = Processor.process_register_range_reset_heavy_hitter_counter1
    self._processMap["register_write_all_heavy_hitter_counter1"] = Processor.process_register_write_all_heavy_hitter_counter1
    self._processMap["register_hw_sync_write_time_in"] = Processor.process_register_hw_sync_write_time_in
    self._processMap["register_reset_all_write_time_in"] = Processor.process_register_reset_all_write_time_in
    self._processMap["register_range_reset_write_time_in"] = Processor.process_register_range_reset_write_time_in
    self._processMap["register_write_all_write_time_in"] = Processor.process_register_write_all_write_time_in
    self._processMap["register_hw_sync_write_time_eg"] = Processor.process_register_hw_sync_write_time_eg
    self._processMap["register_reset_all_write_time_eg"] = Processor.process_register_reset_all_write_time_eg
    self._processMap["register_range_reset_write_time_eg"] = Processor.process_register_range_reset_write_time_eg
    self._processMap["register_write_all_write_time_eg"] = Processor.process_register_write_all_write_time_eg
    self._processMap["register_hw_sync_countt"] = Processor.process_register_hw_sync_countt
    self._processMap["register_reset_all_countt"] = Processor.process_register_reset_all_countt
    self._processMap["register_range_reset_countt"] = Processor.process_register_range_reset_countt
    self._processMap["register_write_all_countt"] = Processor.process_register_write_all_countt

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_acl_match_spec_to_entry_hdl(self, seqid, iprot, oprot):
    args = acl_match_spec_to_entry_hdl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_match_spec_to_entry_hdl_result()
    try:
      result.success = self._handler.acl_match_spec_to_entry_hdl(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_match_spec_to_entry_hdl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_add_with___meta_init_miss_action_acl__(self, seqid, iprot, oprot):
    args = acl_table_add_with___meta_init_miss_action_acl___args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_add_with___meta_init_miss_action_acl___result()
    try:
      result.success = self._handler.acl_table_add_with___meta_init_miss_action_acl__(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_add_with___meta_init_miss_action_acl__", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_add_with_nop(self, seqid, iprot, oprot):
    args = acl_table_add_with_nop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_add_with_nop_result()
    try:
      result.success = self._handler.acl_table_add_with_nop(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_add_with_nop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_add_with__drop(self, seqid, iprot, oprot):
    args = acl_table_add_with__drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_add_with__drop_result()
    try:
      result.success = self._handler.acl_table_add_with__drop(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_add_with__drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_modify_with___meta_init_miss_action_acl__(self, seqid, iprot, oprot):
    args = acl_table_modify_with___meta_init_miss_action_acl___args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_modify_with___meta_init_miss_action_acl___result()
    try:
      self._handler.acl_table_modify_with___meta_init_miss_action_acl__(args.sess_hdl, args.dev_id, args.entry)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_modify_with___meta_init_miss_action_acl__", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(self, seqid, iprot, oprot):
    args = acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_result()
    try:
      self._handler.acl_table_modify_with___meta_init_miss_action_acl___by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_modify_with___meta_init_miss_action_acl___by_match_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_modify_with_nop(self, seqid, iprot, oprot):
    args = acl_table_modify_with_nop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_modify_with_nop_result()
    try:
      self._handler.acl_table_modify_with_nop(args.sess_hdl, args.dev_id, args.entry)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_modify_with_nop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_modify_with_nop_by_match_spec(self, seqid, iprot, oprot):
    args = acl_table_modify_with_nop_by_match_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_modify_with_nop_by_match_spec_result()
    try:
      self._handler.acl_table_modify_with_nop_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_modify_with_nop_by_match_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_modify_with__drop(self, seqid, iprot, oprot):
    args = acl_table_modify_with__drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_modify_with__drop_result()
    try:
      self._handler.acl_table_modify_with__drop(args.sess_hdl, args.dev_id, args.entry)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_modify_with__drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_modify_with__drop_by_match_spec(self, seqid, iprot, oprot):
    args = acl_table_modify_with__drop_by_match_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_modify_with__drop_by_match_spec_result()
    try:
      self._handler.acl_table_modify_with__drop_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_modify_with__drop_by_match_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_delete(self, seqid, iprot, oprot):
    args = acl_table_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_delete_result()
    try:
      self._handler.acl_table_delete(args.sess_hdl, args.dev_id, args.entry)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_delete_by_match_spec(self, seqid, iprot, oprot):
    args = acl_table_delete_by_match_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_delete_by_match_spec_result()
    try:
      self._handler.acl_table_delete_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec, args.priority)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_delete_by_match_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_table_reset_default_entry(self, seqid, iprot, oprot):
    args = update_countt_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_table_reset_default_entry_result()
    try:
      self._handler.update_countt_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_table_reset_default_entry(self, seqid, iprot, oprot):
    args = time32_in_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_table_reset_default_entry_result()
    try:
      self._handler.time32_in_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_in_table_reset_default_entry(self, seqid, iprot, oprot):
    args = write_time_in_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_in_table_reset_default_entry_result()
    try:
      self._handler.write_time_in_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_in_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_table_reset_default_entry(self, seqid, iprot, oprot):
    args = time32_eg_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_table_reset_default_entry_result()
    try:
      self._handler.time32_eg_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_eg_table_reset_default_entry(self, seqid, iprot, oprot):
    args = write_time_eg_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_eg_table_reset_default_entry_result()
    try:
      self._handler.write_time_eg_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_eg_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_table_reset_default_entry(self, seqid, iprot, oprot):
    args = session_check_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_table_reset_default_entry_result()
    try:
      self._handler.session_check_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_table_reset_default_entry(self, seqid, iprot, oprot):
    args = session_check_reverse_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_table_reset_default_entry_result()
    try:
      self._handler.session_check_reverse_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_table_reset_default_entry(self, seqid, iprot, oprot):
    args = read_seq_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_table_reset_default_entry_result()
    try:
      self._handler.read_seq_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_reverse_table_reset_default_entry(self, seqid, iprot, oprot):
    args = read_seq_reverse_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_reverse_table_reset_default_entry_result()
    try:
      self._handler.read_seq_reverse_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_reverse_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_seq_table_reset_default_entry(self, seqid, iprot, oprot):
    args = write_seq_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_seq_table_reset_default_entry_result()
    try:
      self._handler.write_seq_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_seq_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_table_reset_default_entry(self, seqid, iprot, oprot):
    args = session_init_table_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_table_reset_default_entry_result()
    try:
      self._handler.session_init_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_table_reset_default_entry(self, seqid, iprot, oprot):
    args = session_complete_table_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_table_reset_default_entry_result()
    try:
      self._handler.session_complete_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_table_reset_default_entry(self, seqid, iprot, oprot):
    args = relay_session_table_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_table_reset_default_entry_result()
    try:
      self._handler.relay_session_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_table_reset_default_entry(self, seqid, iprot, oprot):
    args = inbound_tran_table_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_table_reset_default_entry_result()
    try:
      self._handler.inbound_tran_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_table_reset_default_entry(self, seqid, iprot, oprot):
    args = outbound_tran_table_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_table_reset_default_entry_result()
    try:
      self._handler.outbound_tran_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_table_reset_default_entry(self, seqid, iprot, oprot):
    args = report_table_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_table_reset_default_entry_result()
    try:
      self._handler.report_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_table_reset_default_entry(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_table_reset_default_entry_result()
    try:
      self._handler.set_heavy_hitter_count_table_1_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_table_reset_default_entry(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_table_reset_default_entry_result()
    try:
      self._handler.set_heavy_hitter_count_table_2_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_table_reset_default_entry(self, seqid, iprot, oprot):
    args = acl_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_table_reset_default_entry_result()
    try:
      self._handler.acl_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_table_reset_default_entry(self, seqid, iprot, oprot):
    args = init_table_reset_default_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_table_reset_default_entry_result()
    try:
      self._handler.init_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_table_reset_default_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_get_entry_count(self, seqid, iprot, oprot):
    args = update_countt_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_get_entry_count_result()
    try:
      result.success = self._handler.update_countt_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_get_entry_count(self, seqid, iprot, oprot):
    args = time32_in_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_get_entry_count_result()
    try:
      result.success = self._handler.time32_in_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_in_get_entry_count(self, seqid, iprot, oprot):
    args = write_time_in_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_in_get_entry_count_result()
    try:
      result.success = self._handler.write_time_in_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_in_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_get_entry_count(self, seqid, iprot, oprot):
    args = time32_eg_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_get_entry_count_result()
    try:
      result.success = self._handler.time32_eg_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_eg_get_entry_count(self, seqid, iprot, oprot):
    args = write_time_eg_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_eg_get_entry_count_result()
    try:
      result.success = self._handler.write_time_eg_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_eg_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_get_entry_count(self, seqid, iprot, oprot):
    args = session_check_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_get_entry_count_result()
    try:
      result.success = self._handler.session_check_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_get_entry_count(self, seqid, iprot, oprot):
    args = session_check_reverse_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_get_entry_count_result()
    try:
      result.success = self._handler.session_check_reverse_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_get_entry_count(self, seqid, iprot, oprot):
    args = read_seq_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_get_entry_count_result()
    try:
      result.success = self._handler.read_seq_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_reverse_get_entry_count(self, seqid, iprot, oprot):
    args = read_seq_reverse_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_reverse_get_entry_count_result()
    try:
      result.success = self._handler.read_seq_reverse_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_reverse_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_seq_get_entry_count(self, seqid, iprot, oprot):
    args = write_seq_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_seq_get_entry_count_result()
    try:
      result.success = self._handler.write_seq_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_seq_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_get_entry_count(self, seqid, iprot, oprot):
    args = session_init_table_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_get_entry_count_result()
    try:
      result.success = self._handler.session_init_table_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_get_entry_count(self, seqid, iprot, oprot):
    args = session_complete_table_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_get_entry_count_result()
    try:
      result.success = self._handler.session_complete_table_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_get_entry_count(self, seqid, iprot, oprot):
    args = relay_session_table_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_get_entry_count_result()
    try:
      result.success = self._handler.relay_session_table_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_get_entry_count(self, seqid, iprot, oprot):
    args = inbound_tran_table_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_get_entry_count_result()
    try:
      result.success = self._handler.inbound_tran_table_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_get_entry_count(self, seqid, iprot, oprot):
    args = outbound_tran_table_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_get_entry_count_result()
    try:
      result.success = self._handler.outbound_tran_table_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_get_entry_count(self, seqid, iprot, oprot):
    args = report_table_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_get_entry_count_result()
    try:
      result.success = self._handler.report_table_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_get_entry_count(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_get_entry_count_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_1_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_get_entry_count(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_get_entry_count_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_2_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_get_entry_count(self, seqid, iprot, oprot):
    args = acl_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_get_entry_count_result()
    try:
      result.success = self._handler.acl_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_get_entry_count(self, seqid, iprot, oprot):
    args = init_get_entry_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_get_entry_count_result()
    try:
      result.success = self._handler.init_get_entry_count(args.sess_hdl, args.dev_id)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_get_entry_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_get_first_entry_handle(self, seqid, iprot, oprot):
    args = update_countt_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_get_first_entry_handle_result()
    try:
      result.success = self._handler.update_countt_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_get_next_entry_handles(self, seqid, iprot, oprot):
    args = update_countt_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_get_next_entry_handles_result()
    try:
      result.success = self._handler.update_countt_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_get_entry(self, seqid, iprot, oprot):
    args = update_countt_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_get_entry_result()
    try:
      result.success = self._handler.update_countt_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_get_first_entry_handle(self, seqid, iprot, oprot):
    args = time32_in_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_get_first_entry_handle_result()
    try:
      result.success = self._handler.time32_in_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_get_next_entry_handles(self, seqid, iprot, oprot):
    args = time32_in_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_get_next_entry_handles_result()
    try:
      result.success = self._handler.time32_in_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_get_entry(self, seqid, iprot, oprot):
    args = time32_in_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_get_entry_result()
    try:
      result.success = self._handler.time32_in_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_in_get_first_entry_handle(self, seqid, iprot, oprot):
    args = write_time_in_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_in_get_first_entry_handle_result()
    try:
      result.success = self._handler.write_time_in_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_in_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_in_get_next_entry_handles(self, seqid, iprot, oprot):
    args = write_time_in_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_in_get_next_entry_handles_result()
    try:
      result.success = self._handler.write_time_in_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_in_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_in_get_entry(self, seqid, iprot, oprot):
    args = write_time_in_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_in_get_entry_result()
    try:
      result.success = self._handler.write_time_in_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_in_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_get_first_entry_handle(self, seqid, iprot, oprot):
    args = time32_eg_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_get_first_entry_handle_result()
    try:
      result.success = self._handler.time32_eg_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_get_next_entry_handles(self, seqid, iprot, oprot):
    args = time32_eg_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_get_next_entry_handles_result()
    try:
      result.success = self._handler.time32_eg_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_get_entry(self, seqid, iprot, oprot):
    args = time32_eg_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_get_entry_result()
    try:
      result.success = self._handler.time32_eg_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_eg_get_first_entry_handle(self, seqid, iprot, oprot):
    args = write_time_eg_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_eg_get_first_entry_handle_result()
    try:
      result.success = self._handler.write_time_eg_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_eg_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_eg_get_next_entry_handles(self, seqid, iprot, oprot):
    args = write_time_eg_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_eg_get_next_entry_handles_result()
    try:
      result.success = self._handler.write_time_eg_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_eg_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_eg_get_entry(self, seqid, iprot, oprot):
    args = write_time_eg_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_eg_get_entry_result()
    try:
      result.success = self._handler.write_time_eg_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_eg_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_get_first_entry_handle(self, seqid, iprot, oprot):
    args = session_check_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_get_first_entry_handle_result()
    try:
      result.success = self._handler.session_check_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_get_next_entry_handles(self, seqid, iprot, oprot):
    args = session_check_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_get_next_entry_handles_result()
    try:
      result.success = self._handler.session_check_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_get_entry(self, seqid, iprot, oprot):
    args = session_check_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_get_entry_result()
    try:
      result.success = self._handler.session_check_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_get_first_entry_handle(self, seqid, iprot, oprot):
    args = session_check_reverse_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_get_first_entry_handle_result()
    try:
      result.success = self._handler.session_check_reverse_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_get_next_entry_handles(self, seqid, iprot, oprot):
    args = session_check_reverse_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_get_next_entry_handles_result()
    try:
      result.success = self._handler.session_check_reverse_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_get_entry(self, seqid, iprot, oprot):
    args = session_check_reverse_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_get_entry_result()
    try:
      result.success = self._handler.session_check_reverse_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_get_first_entry_handle(self, seqid, iprot, oprot):
    args = read_seq_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_get_first_entry_handle_result()
    try:
      result.success = self._handler.read_seq_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_get_next_entry_handles(self, seqid, iprot, oprot):
    args = read_seq_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_get_next_entry_handles_result()
    try:
      result.success = self._handler.read_seq_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_get_entry(self, seqid, iprot, oprot):
    args = read_seq_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_get_entry_result()
    try:
      result.success = self._handler.read_seq_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_reverse_get_first_entry_handle(self, seqid, iprot, oprot):
    args = read_seq_reverse_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_reverse_get_first_entry_handle_result()
    try:
      result.success = self._handler.read_seq_reverse_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_reverse_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_reverse_get_next_entry_handles(self, seqid, iprot, oprot):
    args = read_seq_reverse_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_reverse_get_next_entry_handles_result()
    try:
      result.success = self._handler.read_seq_reverse_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_reverse_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_reverse_get_entry(self, seqid, iprot, oprot):
    args = read_seq_reverse_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_reverse_get_entry_result()
    try:
      result.success = self._handler.read_seq_reverse_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_reverse_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_seq_get_first_entry_handle(self, seqid, iprot, oprot):
    args = write_seq_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_seq_get_first_entry_handle_result()
    try:
      result.success = self._handler.write_seq_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_seq_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_seq_get_next_entry_handles(self, seqid, iprot, oprot):
    args = write_seq_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_seq_get_next_entry_handles_result()
    try:
      result.success = self._handler.write_seq_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_seq_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_seq_get_entry(self, seqid, iprot, oprot):
    args = write_seq_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_seq_get_entry_result()
    try:
      result.success = self._handler.write_seq_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_seq_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_get_first_entry_handle(self, seqid, iprot, oprot):
    args = session_init_table_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_get_first_entry_handle_result()
    try:
      result.success = self._handler.session_init_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_get_next_entry_handles(self, seqid, iprot, oprot):
    args = session_init_table_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_get_next_entry_handles_result()
    try:
      result.success = self._handler.session_init_table_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_get_entry(self, seqid, iprot, oprot):
    args = session_init_table_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_get_entry_result()
    try:
      result.success = self._handler.session_init_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_get_first_entry_handle(self, seqid, iprot, oprot):
    args = session_complete_table_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_get_first_entry_handle_result()
    try:
      result.success = self._handler.session_complete_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_get_next_entry_handles(self, seqid, iprot, oprot):
    args = session_complete_table_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_get_next_entry_handles_result()
    try:
      result.success = self._handler.session_complete_table_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_get_entry(self, seqid, iprot, oprot):
    args = session_complete_table_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_get_entry_result()
    try:
      result.success = self._handler.session_complete_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_get_first_entry_handle(self, seqid, iprot, oprot):
    args = relay_session_table_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_get_first_entry_handle_result()
    try:
      result.success = self._handler.relay_session_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_get_next_entry_handles(self, seqid, iprot, oprot):
    args = relay_session_table_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_get_next_entry_handles_result()
    try:
      result.success = self._handler.relay_session_table_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_get_entry(self, seqid, iprot, oprot):
    args = relay_session_table_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_get_entry_result()
    try:
      result.success = self._handler.relay_session_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_get_first_entry_handle(self, seqid, iprot, oprot):
    args = inbound_tran_table_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_get_first_entry_handle_result()
    try:
      result.success = self._handler.inbound_tran_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_get_next_entry_handles(self, seqid, iprot, oprot):
    args = inbound_tran_table_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_get_next_entry_handles_result()
    try:
      result.success = self._handler.inbound_tran_table_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_get_entry(self, seqid, iprot, oprot):
    args = inbound_tran_table_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_get_entry_result()
    try:
      result.success = self._handler.inbound_tran_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_get_first_entry_handle(self, seqid, iprot, oprot):
    args = outbound_tran_table_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_get_first_entry_handle_result()
    try:
      result.success = self._handler.outbound_tran_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_get_next_entry_handles(self, seqid, iprot, oprot):
    args = outbound_tran_table_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_get_next_entry_handles_result()
    try:
      result.success = self._handler.outbound_tran_table_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_get_entry(self, seqid, iprot, oprot):
    args = outbound_tran_table_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_get_entry_result()
    try:
      result.success = self._handler.outbound_tran_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_get_first_entry_handle(self, seqid, iprot, oprot):
    args = report_table_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_get_first_entry_handle_result()
    try:
      result.success = self._handler.report_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_get_next_entry_handles(self, seqid, iprot, oprot):
    args = report_table_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_get_next_entry_handles_result()
    try:
      result.success = self._handler.report_table_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_get_entry(self, seqid, iprot, oprot):
    args = report_table_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_get_entry_result()
    try:
      result.success = self._handler.report_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_get_first_entry_handle(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_get_first_entry_handle_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_1_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_get_next_entry_handles(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_get_next_entry_handles_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_1_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_get_entry(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_get_entry_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_1_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_get_first_entry_handle(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_get_first_entry_handle_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_2_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_get_next_entry_handles(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_get_next_entry_handles_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_2_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_get_entry(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_get_entry_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_2_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_get_first_entry_handle(self, seqid, iprot, oprot):
    args = acl_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_get_first_entry_handle_result()
    try:
      result.success = self._handler.acl_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_get_next_entry_handles(self, seqid, iprot, oprot):
    args = acl_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_get_next_entry_handles_result()
    try:
      result.success = self._handler.acl_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_get_entry(self, seqid, iprot, oprot):
    args = acl_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_get_entry_result()
    try:
      result.success = self._handler.acl_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_get_first_entry_handle(self, seqid, iprot, oprot):
    args = init_get_first_entry_handle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_get_first_entry_handle_result()
    try:
      result.success = self._handler.init_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_get_first_entry_handle", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_get_next_entry_handles(self, seqid, iprot, oprot):
    args = init_get_next_entry_handles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_get_next_entry_handles_result()
    try:
      result.success = self._handler.init_get_next_entry_handles(args.sess_hdl, args.dev_id, args.entry_hdl, args.n)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_get_next_entry_handles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_get_entry(self, seqid, iprot, oprot):
    args = init_get_entry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_get_entry_result()
    try:
      result.success = self._handler.init_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_get_entry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_set_default_action_update_countt(self, seqid, iprot, oprot):
    args = update_countt_set_default_action_update_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_set_default_action_update_countt_result()
    try:
      result.success = self._handler.update_countt_set_default_action_update_countt(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_set_default_action_update_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_set_default_action_time32_in(self, seqid, iprot, oprot):
    args = time32_in_set_default_action_time32_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_set_default_action_time32_in_result()
    try:
      result.success = self._handler.time32_in_set_default_action_time32_in(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_set_default_action_time32_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_set_default_action_time32_eg(self, seqid, iprot, oprot):
    args = time32_eg_set_default_action_time32_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_set_default_action_time32_eg_result()
    try:
      result.success = self._handler.time32_eg_set_default_action_time32_eg(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_set_default_action_time32_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_set_default_action_lookup_session_map(self, seqid, iprot, oprot):
    args = session_check_set_default_action_lookup_session_map_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_set_default_action_lookup_session_map_result()
    try:
      result.success = self._handler.session_check_set_default_action_lookup_session_map(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_set_default_action_lookup_session_map", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_set_default_action_lookup_session_map_reverse(self, seqid, iprot, oprot):
    args = session_check_reverse_set_default_action_lookup_session_map_reverse_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_set_default_action_lookup_session_map_reverse_result()
    try:
      result.success = self._handler.session_check_reverse_set_default_action_lookup_session_map_reverse(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_set_default_action_lookup_session_map_reverse", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_set_default_action_sendback_sa(self, seqid, iprot, oprot):
    args = session_init_table_set_default_action_sendback_sa_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_set_default_action_sendback_sa_result()
    try:
      result.success = self._handler.session_init_table_set_default_action_sendback_sa(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_set_default_action_sendback_sa", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_set_default_action_sendh2syn(self, seqid, iprot, oprot):
    args = session_complete_table_set_default_action_sendh2syn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_set_default_action_sendh2syn_result()
    try:
      result.success = self._handler.session_complete_table_set_default_action_sendh2syn(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_set_default_action_sendh2syn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_set_default_action_sendh2ack(self, seqid, iprot, oprot):
    args = relay_session_table_set_default_action_sendh2ack_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_set_default_action_sendh2ack_result()
    try:
      result.success = self._handler.relay_session_table_set_default_action_sendh2ack(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_set_default_action_sendh2ack", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_set_default_action_inbound_transformation(self, seqid, iprot, oprot):
    args = inbound_tran_table_set_default_action_inbound_transformation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_set_default_action_inbound_transformation_result()
    try:
      result.success = self._handler.inbound_tran_table_set_default_action_inbound_transformation(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_set_default_action_inbound_transformation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_set_default_action_outbound_transformation(self, seqid, iprot, oprot):
    args = outbound_tran_table_set_default_action_outbound_transformation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_set_default_action_outbound_transformation_result()
    try:
      result.success = self._handler.outbound_tran_table_set_default_action_outbound_transformation(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_set_default_action_outbound_transformation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_set_default_action_report(self, seqid, iprot, oprot):
    args = report_table_set_default_action_report_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_set_default_action_report_result()
    try:
      result.success = self._handler.report_table_set_default_action_report(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_set_default_action_report", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_result()
    try:
      result.success = self._handler.set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_set_default_action___meta_init_miss_action_acl__(self, seqid, iprot, oprot):
    args = acl_set_default_action___meta_init_miss_action_acl___args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_set_default_action___meta_init_miss_action_acl___result()
    try:
      result.success = self._handler.acl_set_default_action___meta_init_miss_action_acl__(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_set_default_action___meta_init_miss_action_acl__", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_set_default_action_nop(self, seqid, iprot, oprot):
    args = acl_set_default_action_nop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_set_default_action_nop_result()
    try:
      result.success = self._handler.acl_set_default_action_nop(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_set_default_action_nop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_set_default_action__drop(self, seqid, iprot, oprot):
    args = acl_set_default_action__drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_set_default_action__drop_result()
    try:
      result.success = self._handler.acl_set_default_action__drop(args.sess_hdl, args.dev_tgt)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_set_default_action__drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_set_default_action_init_action(self, seqid, iprot, oprot):
    args = init_set_default_action_init_action_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_set_default_action_init_action_result()
    try:
      result.success = self._handler.init_set_default_action_init_action(args.sess_hdl, args.dev_tgt, args.action_spec)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_set_default_action_init_action", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_countt_set_property(self, seqid, iprot, oprot):
    args = update_countt_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_countt_set_property_result()
    try:
      self._handler.update_countt_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("update_countt_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_in_set_property(self, seqid, iprot, oprot):
    args = time32_in_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_in_set_property_result()
    try:
      self._handler.time32_in_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_in_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_in_set_property(self, seqid, iprot, oprot):
    args = write_time_in_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_in_set_property_result()
    try:
      self._handler.write_time_in_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_in_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time32_eg_set_property(self, seqid, iprot, oprot):
    args = time32_eg_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time32_eg_set_property_result()
    try:
      self._handler.time32_eg_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("time32_eg_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_time_eg_set_property(self, seqid, iprot, oprot):
    args = write_time_eg_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_time_eg_set_property_result()
    try:
      self._handler.write_time_eg_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_time_eg_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_set_property(self, seqid, iprot, oprot):
    args = session_check_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_set_property_result()
    try:
      self._handler.session_check_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_check_reverse_set_property(self, seqid, iprot, oprot):
    args = session_check_reverse_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_check_reverse_set_property_result()
    try:
      self._handler.session_check_reverse_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_check_reverse_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_set_property(self, seqid, iprot, oprot):
    args = read_seq_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_set_property_result()
    try:
      self._handler.read_seq_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read_seq_reverse_set_property(self, seqid, iprot, oprot):
    args = read_seq_reverse_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_seq_reverse_set_property_result()
    try:
      self._handler.read_seq_reverse_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read_seq_reverse_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write_seq_set_property(self, seqid, iprot, oprot):
    args = write_seq_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_seq_set_property_result()
    try:
      self._handler.write_seq_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write_seq_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_init_table_set_property(self, seqid, iprot, oprot):
    args = session_init_table_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_init_table_set_property_result()
    try:
      self._handler.session_init_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_init_table_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_session_complete_table_set_property(self, seqid, iprot, oprot):
    args = session_complete_table_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = session_complete_table_set_property_result()
    try:
      self._handler.session_complete_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("session_complete_table_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_relay_session_table_set_property(self, seqid, iprot, oprot):
    args = relay_session_table_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = relay_session_table_set_property_result()
    try:
      self._handler.relay_session_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("relay_session_table_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inbound_tran_table_set_property(self, seqid, iprot, oprot):
    args = inbound_tran_table_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inbound_tran_table_set_property_result()
    try:
      self._handler.inbound_tran_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("inbound_tran_table_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_outbound_tran_table_set_property(self, seqid, iprot, oprot):
    args = outbound_tran_table_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = outbound_tran_table_set_property_result()
    try:
      self._handler.outbound_tran_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("outbound_tran_table_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_report_table_set_property(self, seqid, iprot, oprot):
    args = report_table_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = report_table_set_property_result()
    try:
      self._handler.report_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("report_table_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_1_set_property(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_1_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_1_set_property_result()
    try:
      self._handler.set_heavy_hitter_count_table_1_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_1_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_heavy_hitter_count_table_2_set_property(self, seqid, iprot, oprot):
    args = set_heavy_hitter_count_table_2_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_heavy_hitter_count_table_2_set_property_result()
    try:
      self._handler.set_heavy_hitter_count_table_2_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_heavy_hitter_count_table_2_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acl_set_property(self, seqid, iprot, oprot):
    args = acl_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acl_set_property_result()
    try:
      self._handler.acl_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("acl_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init_set_property(self, seqid, iprot, oprot):
    args = init_set_property_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_set_property_result()
    try:
      self._handler.init_set_property(args.sess_hdl, args.dev_id, args.property, args.value)
    except InvalidTableOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("init_set_property", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_hash_fields_register(self, seqid, iprot, oprot):
    args = hash_fields_register_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hash_fields_register_result()
    try:
      self._handler.hash_fields_register(args.sess_hdl, args.dev_id)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("hash_fields_register", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_hash_fields_deregister(self, seqid, iprot, oprot):
    args = hash_fields_deregister_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hash_fields_deregister_result()
    try:
      self._handler.hash_fields_deregister(args.sess_hdl, args.dev_id)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("hash_fields_deregister", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_hash_fields_get_digest(self, seqid, iprot, oprot):
    args = hash_fields_get_digest_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hash_fields_get_digest_result()
    try:
      result.success = self._handler.hash_fields_get_digest(args.sess_hdl)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("hash_fields_get_digest", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_hash_fields_digest_notify_ack(self, seqid, iprot, oprot):
    args = hash_fields_digest_notify_ack_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hash_fields_digest_notify_ack_result()
    try:
      self._handler.hash_fields_digest_notify_ack(args.sess_hdl, args.msg_ptr)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("hash_fields_digest_notify_ack", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_learning_timeout(self, seqid, iprot, oprot):
    args = set_learning_timeout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_learning_timeout_result()
    try:
      self._handler.set_learning_timeout(args.sess_hdl, args.dev_id, args.usecs)
    except InvalidLearnOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("set_learning_timeout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_type_set(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_type_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_type_set_result()
    try:
      self._handler.tbl_dbg_counter_type_set(args.dev_tgt, args.tbl_name, args.type)
    except InvalidDbgOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tbl_dbg_counter_type_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_get(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_get_result()
    try:
      result.success = self._handler.tbl_dbg_counter_get(args.dev_tgt, args.tbl_name)
    except InvalidDbgOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tbl_dbg_counter_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_clear(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_clear_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_clear_result()
    try:
      self._handler.tbl_dbg_counter_clear(args.dev_tgt, args.tbl_name)
    except InvalidDbgOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tbl_dbg_counter_clear", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_type_stage_set(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_type_stage_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_type_stage_set_result()
    try:
      self._handler.tbl_dbg_counter_type_stage_set(args.dev_tgt, args.stage, args.type)
    except InvalidDbgOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tbl_dbg_counter_type_stage_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tbl_dbg_counter_stage_clear(self, seqid, iprot, oprot):
    args = tbl_dbg_counter_stage_clear_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tbl_dbg_counter_stage_clear_result()
    try:
      self._handler.tbl_dbg_counter_stage_clear(args.dev_tgt, args.stage)
    except InvalidDbgOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tbl_dbg_counter_stage_clear", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_create(self, seqid, iprot, oprot):
    args = snapshot_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_create_result()
    try:
      result.success = self._handler.snapshot_create(args.dev_tgt, args.start_stage, args.end_stage, args.direction)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_delete(self, seqid, iprot, oprot):
    args = snapshot_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_delete_result()
    try:
      self._handler.snapshot_delete(args.handle)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_state_set(self, seqid, iprot, oprot):
    args = snapshot_state_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_state_set_result()
    try:
      self._handler.snapshot_state_set(args.handle, args.state, args.usecs)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_state_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_state_get(self, seqid, iprot, oprot):
    args = snapshot_state_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_state_get_result()
    try:
      result.success = self._handler.snapshot_state_get(args.handle, args.pipe)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_state_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_timer_enable(self, seqid, iprot, oprot):
    args = snapshot_timer_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_timer_enable_result()
    try:
      self._handler.snapshot_timer_enable(args.handle, args.disable)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_timer_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_capture_trigger_set(self, seqid, iprot, oprot):
    args = snapshot_capture_trigger_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_capture_trigger_set_result()
    try:
      self._handler.snapshot_capture_trigger_set(args.handle, args.trig_spec, args.trig_spec2)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_capture_trigger_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_capture_data_get(self, seqid, iprot, oprot):
    args = snapshot_capture_data_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_capture_data_get_result()
    try:
      result.success = self._handler.snapshot_capture_data_get(args.handle, args.pipe, args.stage_id, args.field_name)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_capture_data_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_field_in_scope(self, seqid, iprot, oprot):
    args = snapshot_field_in_scope_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_field_in_scope_result()
    try:
      result.success = self._handler.snapshot_field_in_scope(args.dev_tgt, args.stage, args.direction, args.field_name)
    except InvalidSnapshotOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("snapshot_field_in_scope", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_read_h2_seq(self, seqid, iprot, oprot):
    args = register_read_h2_seq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_read_h2_seq_result()
    try:
      result.success = self._handler.register_read_h2_seq(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_read_h2_seq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_h2_seq(self, seqid, iprot, oprot):
    args = register_write_h2_seq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_h2_seq_result()
    try:
      self._handler.register_write_h2_seq(args.sess_hdl, args.dev_tgt, args.index, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_h2_seq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_read_heavy_hitter_counter2(self, seqid, iprot, oprot):
    args = register_read_heavy_hitter_counter2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_read_heavy_hitter_counter2_result()
    try:
      result.success = self._handler.register_read_heavy_hitter_counter2(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_read_heavy_hitter_counter2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_heavy_hitter_counter2(self, seqid, iprot, oprot):
    args = register_write_heavy_hitter_counter2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_heavy_hitter_counter2_result()
    try:
      self._handler.register_write_heavy_hitter_counter2(args.sess_hdl, args.dev_tgt, args.index, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_heavy_hitter_counter2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_read_heavy_hitter_counter1(self, seqid, iprot, oprot):
    args = register_read_heavy_hitter_counter1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_read_heavy_hitter_counter1_result()
    try:
      result.success = self._handler.register_read_heavy_hitter_counter1(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_read_heavy_hitter_counter1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_heavy_hitter_counter1(self, seqid, iprot, oprot):
    args = register_write_heavy_hitter_counter1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_heavy_hitter_counter1_result()
    try:
      self._handler.register_write_heavy_hitter_counter1(args.sess_hdl, args.dev_tgt, args.index, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_heavy_hitter_counter1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_read_write_time_in(self, seqid, iprot, oprot):
    args = register_read_write_time_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_read_write_time_in_result()
    try:
      result.success = self._handler.register_read_write_time_in(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_read_write_time_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_write_time_in(self, seqid, iprot, oprot):
    args = register_write_write_time_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_write_time_in_result()
    try:
      self._handler.register_write_write_time_in(args.sess_hdl, args.dev_tgt, args.index, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_write_time_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_read_write_time_eg(self, seqid, iprot, oprot):
    args = register_read_write_time_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_read_write_time_eg_result()
    try:
      result.success = self._handler.register_read_write_time_eg(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_read_write_time_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_write_time_eg(self, seqid, iprot, oprot):
    args = register_write_write_time_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_write_time_eg_result()
    try:
      self._handler.register_write_write_time_eg(args.sess_hdl, args.dev_tgt, args.index, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_write_time_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_read_countt(self, seqid, iprot, oprot):
    args = register_read_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_read_countt_result()
    try:
      result.success = self._handler.register_read_countt(args.sess_hdl, args.dev_tgt, args.index, args.flags)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_read_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_countt(self, seqid, iprot, oprot):
    args = register_write_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_countt_result()
    try:
      self._handler.register_write_countt(args.sess_hdl, args.dev_tgt, args.index, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_hw_sync_h2_seq(self, seqid, iprot, oprot):
    args = register_hw_sync_h2_seq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_hw_sync_h2_seq_result()
    try:
      self._handler.register_hw_sync_h2_seq(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_hw_sync_h2_seq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_reset_all_h2_seq(self, seqid, iprot, oprot):
    args = register_reset_all_h2_seq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_reset_all_h2_seq_result()
    try:
      self._handler.register_reset_all_h2_seq(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_reset_all_h2_seq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_range_reset_h2_seq(self, seqid, iprot, oprot):
    args = register_range_reset_h2_seq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_range_reset_h2_seq_result()
    try:
      self._handler.register_range_reset_h2_seq(args.sess_hdl, args.dev_tgt, args.index, args.count)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_range_reset_h2_seq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_all_h2_seq(self, seqid, iprot, oprot):
    args = register_write_all_h2_seq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_all_h2_seq_result()
    try:
      self._handler.register_write_all_h2_seq(args.sess_hdl, args.dev_tgt, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_all_h2_seq", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_hw_sync_heavy_hitter_counter2(self, seqid, iprot, oprot):
    args = register_hw_sync_heavy_hitter_counter2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_hw_sync_heavy_hitter_counter2_result()
    try:
      self._handler.register_hw_sync_heavy_hitter_counter2(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_hw_sync_heavy_hitter_counter2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_reset_all_heavy_hitter_counter2(self, seqid, iprot, oprot):
    args = register_reset_all_heavy_hitter_counter2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_reset_all_heavy_hitter_counter2_result()
    try:
      self._handler.register_reset_all_heavy_hitter_counter2(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_reset_all_heavy_hitter_counter2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_range_reset_heavy_hitter_counter2(self, seqid, iprot, oprot):
    args = register_range_reset_heavy_hitter_counter2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_range_reset_heavy_hitter_counter2_result()
    try:
      self._handler.register_range_reset_heavy_hitter_counter2(args.sess_hdl, args.dev_tgt, args.index, args.count)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_range_reset_heavy_hitter_counter2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_all_heavy_hitter_counter2(self, seqid, iprot, oprot):
    args = register_write_all_heavy_hitter_counter2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_all_heavy_hitter_counter2_result()
    try:
      self._handler.register_write_all_heavy_hitter_counter2(args.sess_hdl, args.dev_tgt, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_all_heavy_hitter_counter2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_hw_sync_heavy_hitter_counter1(self, seqid, iprot, oprot):
    args = register_hw_sync_heavy_hitter_counter1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_hw_sync_heavy_hitter_counter1_result()
    try:
      self._handler.register_hw_sync_heavy_hitter_counter1(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_hw_sync_heavy_hitter_counter1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_reset_all_heavy_hitter_counter1(self, seqid, iprot, oprot):
    args = register_reset_all_heavy_hitter_counter1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_reset_all_heavy_hitter_counter1_result()
    try:
      self._handler.register_reset_all_heavy_hitter_counter1(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_reset_all_heavy_hitter_counter1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_range_reset_heavy_hitter_counter1(self, seqid, iprot, oprot):
    args = register_range_reset_heavy_hitter_counter1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_range_reset_heavy_hitter_counter1_result()
    try:
      self._handler.register_range_reset_heavy_hitter_counter1(args.sess_hdl, args.dev_tgt, args.index, args.count)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_range_reset_heavy_hitter_counter1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_all_heavy_hitter_counter1(self, seqid, iprot, oprot):
    args = register_write_all_heavy_hitter_counter1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_all_heavy_hitter_counter1_result()
    try:
      self._handler.register_write_all_heavy_hitter_counter1(args.sess_hdl, args.dev_tgt, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_all_heavy_hitter_counter1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_hw_sync_write_time_in(self, seqid, iprot, oprot):
    args = register_hw_sync_write_time_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_hw_sync_write_time_in_result()
    try:
      self._handler.register_hw_sync_write_time_in(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_hw_sync_write_time_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_reset_all_write_time_in(self, seqid, iprot, oprot):
    args = register_reset_all_write_time_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_reset_all_write_time_in_result()
    try:
      self._handler.register_reset_all_write_time_in(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_reset_all_write_time_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_range_reset_write_time_in(self, seqid, iprot, oprot):
    args = register_range_reset_write_time_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_range_reset_write_time_in_result()
    try:
      self._handler.register_range_reset_write_time_in(args.sess_hdl, args.dev_tgt, args.index, args.count)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_range_reset_write_time_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_all_write_time_in(self, seqid, iprot, oprot):
    args = register_write_all_write_time_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_all_write_time_in_result()
    try:
      self._handler.register_write_all_write_time_in(args.sess_hdl, args.dev_tgt, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_all_write_time_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_hw_sync_write_time_eg(self, seqid, iprot, oprot):
    args = register_hw_sync_write_time_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_hw_sync_write_time_eg_result()
    try:
      self._handler.register_hw_sync_write_time_eg(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_hw_sync_write_time_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_reset_all_write_time_eg(self, seqid, iprot, oprot):
    args = register_reset_all_write_time_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_reset_all_write_time_eg_result()
    try:
      self._handler.register_reset_all_write_time_eg(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_reset_all_write_time_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_range_reset_write_time_eg(self, seqid, iprot, oprot):
    args = register_range_reset_write_time_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_range_reset_write_time_eg_result()
    try:
      self._handler.register_range_reset_write_time_eg(args.sess_hdl, args.dev_tgt, args.index, args.count)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_range_reset_write_time_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_all_write_time_eg(self, seqid, iprot, oprot):
    args = register_write_all_write_time_eg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_all_write_time_eg_result()
    try:
      self._handler.register_write_all_write_time_eg(args.sess_hdl, args.dev_tgt, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_all_write_time_eg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_hw_sync_countt(self, seqid, iprot, oprot):
    args = register_hw_sync_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_hw_sync_countt_result()
    try:
      self._handler.register_hw_sync_countt(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_hw_sync_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_reset_all_countt(self, seqid, iprot, oprot):
    args = register_reset_all_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_reset_all_countt_result()
    try:
      self._handler.register_reset_all_countt(args.sess_hdl, args.dev_tgt)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_reset_all_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_range_reset_countt(self, seqid, iprot, oprot):
    args = register_range_reset_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_range_reset_countt_result()
    try:
      self._handler.register_range_reset_countt(args.sess_hdl, args.dev_tgt, args.index, args.count)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_range_reset_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_write_all_countt(self, seqid, iprot, oprot):
    args = register_write_all_countt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_write_all_countt_result()
    try:
      self._handler.register_write_all_countt(args.sess_hdl, args.dev_tgt, args.register_value)
    except InvalidRegisterOperation, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("register_write_all_countt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class acl_match_spec_to_entry_hdl_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_match_spec_to_entry_hdl_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_match_spec_to_entry_hdl_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_match_spec_to_entry_hdl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_add_with___meta_init_miss_action_acl___args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_add_with___meta_init_miss_action_acl___args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_add_with___meta_init_miss_action_acl___result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_add_with___meta_init_miss_action_acl___result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_add_with_nop_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_add_with_nop_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_add_with_nop_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_add_with_nop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_add_with__drop_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_add_with__drop_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_add_with__drop_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_add_with__drop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with___meta_init_miss_action_acl___args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with___meta_init_miss_action_acl___args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with___meta_init_miss_action_acl___result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with___meta_init_miss_action_acl___result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with___meta_init_miss_action_acl___by_match_spec_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with_nop_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with_nop_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with_nop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with_nop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with_nop_by_match_spec_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with_nop_by_match_spec_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with_nop_by_match_spec_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with_nop_by_match_spec_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with__drop_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with__drop_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with__drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with__drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with__drop_by_match_spec_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with__drop_by_match_spec_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_modify_with__drop_by_match_spec_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_modify_with__drop_by_match_spec_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_delete_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry = entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_delete_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 3)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_delete_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_delete_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_delete_by_match_spec_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - match_spec
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'match_spec', (synproxy_acl_match_spec_t, synproxy_acl_match_spec_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, priority=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.match_spec = match_spec
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.match_spec = synproxy_acl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_delete_by_match_spec_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_delete_by_match_spec_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_delete_by_match_spec_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_table_reset_default_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_table_reset_default_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_table_reset_default_entry_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_table_reset_default_entry_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_entry_count_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_entry_count_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_entry_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_entry_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI32();
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter13 in self.success:
        oprot.writeI32(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_update_countt_entry_desc_t, synproxy_update_countt_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_update_countt_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readI32();
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter20 in self.success:
        oprot.writeI32(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_time32_in_entry_desc_t, synproxy_time32_in_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_time32_in_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readI32();
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter27 in self.success:
        oprot.writeI32(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_write_time_in_entry_desc_t, synproxy_write_time_in_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_write_time_in_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readI32();
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter34 in self.success:
        oprot.writeI32(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_time32_eg_entry_desc_t, synproxy_time32_eg_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_time32_eg_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readI32();
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter41 in self.success:
        oprot.writeI32(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_write_time_eg_entry_desc_t, synproxy_write_time_eg_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_write_time_eg_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readI32();
            self.success.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter48 in self.success:
        oprot.writeI32(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_session_check_entry_desc_t, synproxy_session_check_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_session_check_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readI32();
            self.success.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter55 in self.success:
        oprot.writeI32(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_session_check_reverse_entry_desc_t, synproxy_session_check_reverse_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_session_check_reverse_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = iprot.readI32();
            self.success.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter62 in self.success:
        oprot.writeI32(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_read_seq_entry_desc_t, synproxy_read_seq_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_read_seq_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = iprot.readI32();
            self.success.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter69 in self.success:
        oprot.writeI32(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_read_seq_reverse_entry_desc_t, synproxy_read_seq_reverse_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_read_seq_reverse_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = iprot.readI32();
            self.success.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter76 in self.success:
        oprot.writeI32(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_write_seq_entry_desc_t, synproxy_write_seq_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_write_seq_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readI32();
            self.success.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter83 in self.success:
        oprot.writeI32(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_session_init_table_entry_desc_t, synproxy_session_init_table_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_session_init_table_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = iprot.readI32();
            self.success.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter90 in self.success:
        oprot.writeI32(iter90)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_session_complete_table_entry_desc_t, synproxy_session_complete_table_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_session_complete_table_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = iprot.readI32();
            self.success.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter97 in self.success:
        oprot.writeI32(iter97)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_relay_session_table_entry_desc_t, synproxy_relay_session_table_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_relay_session_table_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = iprot.readI32();
            self.success.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter104 in self.success:
        oprot.writeI32(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_inbound_tran_table_entry_desc_t, synproxy_inbound_tran_table_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_inbound_tran_table_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readI32();
            self.success.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter111 in self.success:
        oprot.writeI32(iter111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_outbound_tran_table_entry_desc_t, synproxy_outbound_tran_table_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_outbound_tran_table_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = iprot.readI32();
            self.success.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter118 in self.success:
        oprot.writeI32(iter118)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_report_table_entry_desc_t, synproxy_report_table_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_report_table_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = iprot.readI32();
            self.success.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter125 in self.success:
        oprot.writeI32(iter125)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_set_heavy_hitter_count_table_1_entry_desc_t, synproxy_set_heavy_hitter_count_table_1_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_set_heavy_hitter_count_table_1_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype129, _size126) = iprot.readListBegin()
          for _i130 in xrange(_size126):
            _elem131 = iprot.readI32();
            self.success.append(_elem131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter132 in self.success:
        oprot.writeI32(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_set_heavy_hitter_count_table_2_entry_desc_t, synproxy_set_heavy_hitter_count_table_2_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_set_heavy_hitter_count_table_2_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype136, _size133) = iprot.readListBegin()
          for _i137 in xrange(_size133):
            _elem138 = iprot.readI32();
            self.success.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter139 in self.success:
        oprot.writeI32(iter139)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_acl_entry_desc_t, synproxy_acl_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_acl_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_first_entry_handle_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_first_entry_handle_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_first_entry_handle_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_first_entry_handle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_next_entry_handles_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.I32, 'n', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, n=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_next_entry_handles_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 4)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.n)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_next_entry_handles_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype143, _size140) = iprot.readListBegin()
          for _i144 in xrange(_size140):
            _elem145 = iprot.readI32();
            self.success.append(_elem145)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_next_entry_handles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter146 in self.success:
        oprot.writeI32(iter146)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_entry_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - entry_hdl
   - read_from_hw
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'entry_hdl', None, None, ), # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.entry_hdl = entry_hdl
    self.read_from_hw = read_from_hw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.read_from_hw = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_entry_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry_hdl is not None:
      oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
      oprot.writeI32(self.entry_hdl)
      oprot.writeFieldEnd()
    if self.read_from_hw is not None:
      oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
      oprot.writeBool(self.read_from_hw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry_hdl)
    value = (value * 31) ^ hash(self.read_from_hw)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_get_entry_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_init_entry_desc_t, synproxy_init_entry_desc_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_init_entry_desc_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_get_entry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_set_default_action_update_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_set_default_action_update_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_set_default_action_update_countt_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_set_default_action_update_countt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_set_default_action_time32_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_set_default_action_time32_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_set_default_action_time32_in_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_set_default_action_time32_in_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_set_default_action_time32_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_set_default_action_time32_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_set_default_action_time32_eg_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_set_default_action_time32_eg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_set_default_action_lookup_session_map_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_set_default_action_lookup_session_map_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_set_default_action_lookup_session_map_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_set_default_action_lookup_session_map_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_set_default_action_lookup_session_map_reverse_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_set_default_action_lookup_session_map_reverse_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_set_default_action_lookup_session_map_reverse_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_set_default_action_lookup_session_map_reverse_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_set_default_action_sendback_sa_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_set_default_action_sendback_sa_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_set_default_action_sendback_sa_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_set_default_action_sendback_sa_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_set_default_action_sendh2syn_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_set_default_action_sendh2syn_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_set_default_action_sendh2syn_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_set_default_action_sendh2syn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_set_default_action_sendh2ack_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_set_default_action_sendh2ack_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_set_default_action_sendh2ack_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_set_default_action_sendh2ack_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_set_default_action_inbound_transformation_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_set_default_action_inbound_transformation_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_set_default_action_inbound_transformation_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_set_default_action_inbound_transformation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_set_default_action_outbound_transformation_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_set_default_action_outbound_transformation_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_set_default_action_outbound_transformation_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_set_default_action_outbound_transformation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_set_default_action_report_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_set_default_action_report_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_set_default_action_report_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_set_default_action_report_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_set_default_action_set_heavy_hitter_count_1_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_set_default_action_set_heavy_hitter_count_2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_default_action___meta_init_miss_action_acl___args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_default_action___meta_init_miss_action_acl___args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_default_action___meta_init_miss_action_acl___result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_default_action___meta_init_miss_action_acl___result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_default_action_nop_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_default_action_nop_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_default_action_nop_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_default_action_nop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_default_action__drop_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_default_action__drop_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_default_action__drop_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_default_action__drop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_set_default_action_init_action_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - action_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'action_spec', (synproxy_init_action_action_spec_t, synproxy_init_action_action_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, action_spec=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.action_spec = action_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.action_spec = synproxy_init_action_action_spec_t()
          self.action_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_set_default_action_init_action_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.action_spec is not None:
      oprot.writeFieldBegin('action_spec', TType.STRUCT, 3)
      self.action_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.action_spec)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_set_default_action_init_action_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_set_default_action_init_action_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_countt_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_countt_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_in_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_in_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_in_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_in_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time32_eg_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time32_eg_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_time_eg_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_time_eg_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_check_reverse_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_check_reverse_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_seq_reverse_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_seq_reverse_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_seq_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_seq_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_init_table_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_init_table_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class session_complete_table_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('session_complete_table_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class relay_session_table_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('relay_session_table_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inbound_tran_table_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inbound_tran_table_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class outbound_tran_table_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('outbound_tran_table_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class report_table_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('report_table_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_1_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_1_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_heavy_hitter_count_table_2_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_heavy_hitter_count_table_2_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acl_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acl_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_set_property_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'property', None, None, ), # 3
    (4, TType.I32, 'value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.property = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_set_property_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.I32, 3)
      oprot.writeI32(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 4)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.property)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_set_property_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTableOperation, InvalidTableOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTableOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_set_property_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_register_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_register_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_register_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_register_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_deregister_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_id=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_deregister_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_deregister_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_deregister_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_get_digest_args:
  """
  Attributes:
   - sess_hdl
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
  )

  def __init__(self, sess_hdl=None,):
    self.sess_hdl = sess_hdl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_get_digest_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_get_digest_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (synproxy_hash_fields_digest_msg_t, synproxy_hash_fields_digest_msg_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = synproxy_hash_fields_digest_msg_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_get_digest_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_digest_notify_ack_args:
  """
  Attributes:
   - sess_hdl
   - msg_ptr
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.I64, 'msg_ptr', None, None, ), # 2
  )

  def __init__(self, sess_hdl=None, msg_ptr=None,):
    self.sess_hdl = sess_hdl
    self.msg_ptr = msg_ptr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.msg_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_digest_notify_ack_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.msg_ptr is not None:
      oprot.writeFieldBegin('msg_ptr', TType.I64, 2)
      oprot.writeI64(self.msg_ptr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.msg_ptr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hash_fields_digest_notify_ack_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hash_fields_digest_notify_ack_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_learning_timeout_args:
  """
  Attributes:
   - sess_hdl
   - dev_id
   - usecs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.BYTE, 'dev_id', None, None, ), # 2
    (3, TType.I32, 'usecs', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_id=None, usecs=None,):
    self.sess_hdl = sess_hdl
    self.dev_id = dev_id
    self.usecs = usecs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.dev_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.usecs = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_learning_timeout_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
      oprot.writeByte(self.dev_id)
      oprot.writeFieldEnd()
    if self.usecs is not None:
      oprot.writeFieldBegin('usecs', TType.I32, 3)
      oprot.writeI32(self.usecs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.usecs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_learning_timeout_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidLearnOperation, InvalidLearnOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidLearnOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_learning_timeout_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_set_args:
  """
  Attributes:
   - dev_tgt
   - tbl_name
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, dev_tgt=None, tbl_name=None, type=None,):
    self.dev_tgt = dev_tgt
    self.tbl_name = tbl_name
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_set_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidDbgOperation, InvalidDbgOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDbgOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_get_args:
  """
  Attributes:
   - dev_tgt
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dev_tgt=None, tbl_name=None,):
    self.dev_tgt = dev_tgt
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_get_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_get_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidDbgOperation, InvalidDbgOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDbgOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_clear_args:
  """
  Attributes:
   - dev_tgt
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dev_tgt=None, tbl_name=None,):
    self.dev_tgt = dev_tgt
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_clear_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_clear_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidDbgOperation, InvalidDbgOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDbgOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_clear_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_stage_set_args:
  """
  Attributes:
   - dev_tgt
   - stage
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'stage', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, dev_tgt=None, stage=None, type=None,):
    self.dev_tgt = dev_tgt
    self.stage = stage
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_stage_set_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.stage is not None:
      oprot.writeFieldBegin('stage', TType.BYTE, 2)
      oprot.writeByte(self.stage)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.stage)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_type_stage_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidDbgOperation, InvalidDbgOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDbgOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_type_stage_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_stage_clear_args:
  """
  Attributes:
   - dev_tgt
   - stage
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'stage', None, None, ), # 2
  )

  def __init__(self, dev_tgt=None, stage=None,):
    self.dev_tgt = dev_tgt
    self.stage = stage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_stage_clear_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.stage is not None:
      oprot.writeFieldBegin('stage', TType.BYTE, 2)
      oprot.writeByte(self.stage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.stage)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_dbg_counter_stage_clear_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidDbgOperation, InvalidDbgOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidDbgOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_dbg_counter_stage_clear_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_create_args:
  """
  Attributes:
   - dev_tgt
   - start_stage
   - end_stage
   - direction
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'start_stage', None, None, ), # 2
    (3, TType.BYTE, 'end_stage', None, None, ), # 3
    (4, TType.BYTE, 'direction', None, None, ), # 4
  )

  def __init__(self, dev_tgt=None, start_stage=None, end_stage=None, direction=None,):
    self.dev_tgt = dev_tgt
    self.start_stage = start_stage
    self.end_stage = end_stage
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.start_stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.end_stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.direction = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_create_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.start_stage is not None:
      oprot.writeFieldBegin('start_stage', TType.BYTE, 2)
      oprot.writeByte(self.start_stage)
      oprot.writeFieldEnd()
    if self.end_stage is not None:
      oprot.writeFieldBegin('end_stage', TType.BYTE, 3)
      oprot.writeByte(self.end_stage)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.BYTE, 4)
      oprot.writeByte(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.start_stage)
    value = (value * 31) ^ hash(self.end_stage)
    value = (value * 31) ^ hash(self.direction)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_create_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_delete_args:
  """
  Attributes:
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
  )

  def __init__(self, handle=None,):
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_delete_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_delete_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_delete_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_set_args:
  """
  Attributes:
   - handle
   - state
   - usecs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
    (3, TType.I32, 'usecs', None, None, ), # 3
  )

  def __init__(self, handle=None, state=None, usecs=None,):
    self.handle = handle
    self.state = state
    self.usecs = usecs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.usecs = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_set_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.usecs is not None:
      oprot.writeFieldBegin('usecs', TType.I32, 3)
      oprot.writeI32(self.usecs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.usecs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_get_args:
  """
  Attributes:
   - handle
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I16, 'pipe', None, None, ), # 2
  )

  def __init__(self, handle=None, pipe=None,):
    self.handle = handle
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.pipe = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_get_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I16, 2)
      oprot.writeI16(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.pipe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_state_get_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_state_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_timer_enable_args:
  """
  Attributes:
   - handle
   - disable
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.BYTE, 'disable', None, None, ), # 2
  )

  def __init__(self, handle=None, disable=None,):
    self.handle = handle
    self.disable = disable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.disable = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_timer_enable_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.disable is not None:
      oprot.writeFieldBegin('disable', TType.BYTE, 2)
      oprot.writeByte(self.disable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.disable)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_timer_enable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_timer_enable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_trigger_set_args:
  """
  Attributes:
   - handle
   - trig_spec
   - trig_spec2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.STRUCT, 'trig_spec', (synproxy_snapshot_trig_spec_t, synproxy_snapshot_trig_spec_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'trig_spec2', (synproxy_snapshot_trig_spec_t, synproxy_snapshot_trig_spec_t.thrift_spec), None, ), # 3
  )

  def __init__(self, handle=None, trig_spec=None, trig_spec2=None,):
    self.handle = handle
    self.trig_spec = trig_spec
    self.trig_spec2 = trig_spec2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.trig_spec = synproxy_snapshot_trig_spec_t()
          self.trig_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.trig_spec2 = synproxy_snapshot_trig_spec_t()
          self.trig_spec2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_trigger_set_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.trig_spec is not None:
      oprot.writeFieldBegin('trig_spec', TType.STRUCT, 2)
      self.trig_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.trig_spec2 is not None:
      oprot.writeFieldBegin('trig_spec2', TType.STRUCT, 3)
      self.trig_spec2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.trig_spec)
    value = (value * 31) ^ hash(self.trig_spec2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_trigger_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_trigger_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_data_get_args:
  """
  Attributes:
   - handle
   - pipe
   - stage_id
   - field_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I16, 'pipe', None, None, ), # 2
    (3, TType.I16, 'stage_id', None, None, ), # 3
    (4, TType.STRING, 'field_name', None, None, ), # 4
  )

  def __init__(self, handle=None, pipe=None, stage_id=None, field_name=None,):
    self.handle = handle
    self.pipe = pipe
    self.stage_id = stage_id
    self.field_name = field_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.pipe = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.stage_id = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.field_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_data_get_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I16, 2)
      oprot.writeI16(self.pipe)
      oprot.writeFieldEnd()
    if self.stage_id is not None:
      oprot.writeFieldBegin('stage_id', TType.I16, 3)
      oprot.writeI16(self.stage_id)
      oprot.writeFieldEnd()
    if self.field_name is not None:
      oprot.writeFieldBegin('field_name', TType.STRING, 4)
      oprot.writeString(self.field_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.stage_id)
    value = (value * 31) ^ hash(self.field_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_capture_data_get_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_capture_data_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_field_in_scope_args:
  """
  Attributes:
   - dev_tgt
   - stage
   - direction
   - field_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.BYTE, 'stage', None, None, ), # 2
    (3, TType.BYTE, 'direction', None, None, ), # 3
    (4, TType.STRING, 'field_name', None, None, ), # 4
  )

  def __init__(self, dev_tgt=None, stage=None, direction=None, field_name=None,):
    self.dev_tgt = dev_tgt
    self.stage = stage
    self.direction = direction
    self.field_name = field_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stage = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.direction = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.field_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_field_in_scope_args')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.stage is not None:
      oprot.writeFieldBegin('stage', TType.BYTE, 2)
      oprot.writeByte(self.stage)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.BYTE, 3)
      oprot.writeByte(self.direction)
      oprot.writeFieldEnd()
    if self.field_name is not None:
      oprot.writeFieldBegin('field_name', TType.STRING, 4)
      oprot.writeString(self.field_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.stage)
    value = (value * 31) ^ hash(self.direction)
    value = (value * 31) ^ hash(self.field_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_field_in_scope_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidSnapshotOperation, InvalidSnapshotOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidSnapshotOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_field_in_scope_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_h2_seq_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (synproxy_register_flags_t, synproxy_register_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = synproxy_register_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_h2_seq_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_h2_seq_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype150, _size147) = iprot.readListBegin()
          for _i151 in xrange(_size147):
            _elem152 = iprot.readI32();
            self.success.append(_elem152)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_h2_seq_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter153 in self.success:
        oprot.writeI32(iter153)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_h2_seq_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'register_value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.register_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_h2_seq_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.I32, 4)
      oprot.writeI32(self.register_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_h2_seq_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_h2_seq_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_heavy_hitter_counter2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (synproxy_register_flags_t, synproxy_register_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = synproxy_register_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_heavy_hitter_counter2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_heavy_hitter_counter2_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype157, _size154) = iprot.readListBegin()
          for _i158 in xrange(_size154):
            _elem159 = iprot.readI32();
            self.success.append(_elem159)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_heavy_hitter_counter2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter160 in self.success:
        oprot.writeI32(iter160)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_heavy_hitter_counter2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'register_value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.register_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_heavy_hitter_counter2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.I32, 4)
      oprot.writeI32(self.register_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_heavy_hitter_counter2_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_heavy_hitter_counter2_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_heavy_hitter_counter1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (synproxy_register_flags_t, synproxy_register_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = synproxy_register_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_heavy_hitter_counter1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_heavy_hitter_counter1_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype164, _size161) = iprot.readListBegin()
          for _i165 in xrange(_size161):
            _elem166 = iprot.readI32();
            self.success.append(_elem166)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_heavy_hitter_counter1_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter167 in self.success:
        oprot.writeI32(iter167)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_heavy_hitter_counter1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'register_value', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.register_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_heavy_hitter_counter1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.I32, 4)
      oprot.writeI32(self.register_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_heavy_hitter_counter1_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_heavy_hitter_counter1_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_write_time_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (synproxy_register_flags_t, synproxy_register_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = synproxy_register_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_write_time_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_write_time_in_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(synproxy_write_time_in_value_t, synproxy_write_time_in_value_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype171, _size168) = iprot.readListBegin()
          for _i172 in xrange(_size168):
            _elem173 = synproxy_write_time_in_value_t()
            _elem173.read(iprot)
            self.success.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_write_time_in_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter174 in self.success:
        iter174.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_write_time_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'register_value', (synproxy_write_time_in_value_t, synproxy_write_time_in_value_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.register_value = synproxy_write_time_in_value_t()
          self.register_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_write_time_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.STRUCT, 4)
      self.register_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_write_time_in_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_write_time_in_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_write_time_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (synproxy_register_flags_t, synproxy_register_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = synproxy_register_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_write_time_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_write_time_eg_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(synproxy_write_time_eg_value_t, synproxy_write_time_eg_value_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype178, _size175) = iprot.readListBegin()
          for _i179 in xrange(_size175):
            _elem180 = synproxy_write_time_eg_value_t()
            _elem180.read(iprot)
            self.success.append(_elem180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_write_time_eg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter181 in self.success:
        iter181.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_write_time_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'register_value', (synproxy_write_time_eg_value_t, synproxy_write_time_eg_value_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.register_value = synproxy_write_time_eg_value_t()
          self.register_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_write_time_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.STRUCT, 4)
      self.register_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_write_time_eg_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_write_time_eg_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'flags', (synproxy_register_flags_t, synproxy_register_flags_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, flags=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.flags = synproxy_register_flags_t()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 4)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_read_countt_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(synproxy_countt_value_t, synproxy_countt_value_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype185, _size182) = iprot.readListBegin()
          for _i186 in xrange(_size182):
            _elem187 = synproxy_countt_value_t()
            _elem187.read(iprot)
            self.success.append(_elem187)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_read_countt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter188 in self.success:
        iter188.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.STRUCT, 'register_value', (synproxy_countt_value_t, synproxy_countt_value_t.thrift_spec), None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.register_value = synproxy_countt_value_t()
          self.register_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.STRUCT, 4)
      self.register_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_countt_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_countt_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_h2_seq_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_h2_seq_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_h2_seq_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_h2_seq_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_h2_seq_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_h2_seq_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_h2_seq_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_h2_seq_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_h2_seq_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, count=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_h2_seq_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_h2_seq_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_h2_seq_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_h2_seq_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'register_value', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.register_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_h2_seq_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.I32, 3)
      oprot.writeI32(self.register_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_h2_seq_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_h2_seq_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_heavy_hitter_counter2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_heavy_hitter_counter2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_heavy_hitter_counter2_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_heavy_hitter_counter2_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_heavy_hitter_counter2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_heavy_hitter_counter2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_heavy_hitter_counter2_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_heavy_hitter_counter2_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_heavy_hitter_counter2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, count=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_heavy_hitter_counter2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_heavy_hitter_counter2_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_heavy_hitter_counter2_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_heavy_hitter_counter2_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'register_value', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.register_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_heavy_hitter_counter2_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.I32, 3)
      oprot.writeI32(self.register_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_heavy_hitter_counter2_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_heavy_hitter_counter2_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_heavy_hitter_counter1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_heavy_hitter_counter1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_heavy_hitter_counter1_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_heavy_hitter_counter1_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_heavy_hitter_counter1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_heavy_hitter_counter1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_heavy_hitter_counter1_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_heavy_hitter_counter1_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_heavy_hitter_counter1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, count=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_heavy_hitter_counter1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_heavy_hitter_counter1_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_heavy_hitter_counter1_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_heavy_hitter_counter1_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'register_value', None, None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.register_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_heavy_hitter_counter1_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.I32, 3)
      oprot.writeI32(self.register_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_heavy_hitter_counter1_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_heavy_hitter_counter1_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_write_time_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_write_time_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_write_time_in_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_write_time_in_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_write_time_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_write_time_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_write_time_in_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_write_time_in_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_write_time_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, count=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_write_time_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_write_time_in_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_write_time_in_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_write_time_in_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'register_value', (synproxy_write_time_in_value_t, synproxy_write_time_in_value_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.register_value = synproxy_write_time_in_value_t()
          self.register_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_write_time_in_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.STRUCT, 3)
      self.register_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_write_time_in_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_write_time_in_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_write_time_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_write_time_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_write_time_eg_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_write_time_eg_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_write_time_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_write_time_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_write_time_eg_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_write_time_eg_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_write_time_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, count=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_write_time_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_write_time_eg_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_write_time_eg_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_write_time_eg_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'register_value', (synproxy_write_time_eg_value_t, synproxy_write_time_eg_value_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.register_value = synproxy_write_time_eg_value_t()
          self.register_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_write_time_eg_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.STRUCT, 3)
      self.register_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_write_time_eg_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_write_time_eg_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_hw_sync_countt_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_hw_sync_countt_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
  )

  def __init__(self, sess_hdl=None, dev_tgt=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_reset_all_countt_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_reset_all_countt_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, index=None, count=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_range_reset_countt_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_range_reset_countt_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_countt_args:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - register_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'register_value', (synproxy_countt_value_t, synproxy_countt_value_t.thrift_spec), None, ), # 3
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, register_value=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.register_value = register_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.register_value = synproxy_countt_value_t()
          self.register_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_countt_args')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.register_value is not None:
      oprot.writeFieldBegin('register_value', TType.STRUCT, 3)
      self.register_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.register_value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_write_all_countt_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidRegisterOperation, InvalidRegisterOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidRegisterOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_write_all_countt_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
